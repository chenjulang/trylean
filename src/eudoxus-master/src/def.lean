import tactic
import group_theory.quotient_group
import algebra.order.archimedean
import order.conditionally_complete_lattice.basic
-- 
-- for quotient_add_group.quotient
-- import group_theory.coset
-- import linear_algebra.quotient
-- import group_theory.congruence
-- import group_theory.coset
-- import group_theory.subgroup.pointwise
-- 
-- for finset.Ico_â„¤
import data.set.intervals
import data.set.finite
-- import data.pnat.intervals
import data.list.intervals
import data.real.basic

open real set function fin

open_locale classical


-- open quotient_group


-- namespace quotient


  -- è¿™æ˜¯ä¸€ä¸ªè¡¡é‡ f çš„â€œæ¥è¿‘çº¿æ€§â€çš„å·®å¼‚çš„å‡½æ•°
  def df (f : â„¤ â†’ â„¤) : â„¤ â†’ â„¤ â†’ â„¤ := Î» p q, f (p + q) - f (p) - f (q)

  def almost_homo (f : â„¤ â†’ â„¤) : Prop := âˆƒ C, âˆ€ p q, abs (df f p q) < C 
  -- å®šä¹‰ä¸€ä¸ªè°“è¯ï¼Œè¡¨ç¤ºå‡½æ•° f â€œå‡ ä¹æ˜¯çº¿æ€§çš„â€ï¼Œ
    -- å³å­˜åœ¨ä¸€ä¸ªå¸¸æ•° Cï¼Œä½¿å¾—å¯¹äºæ‰€æœ‰æ•´æ•° p å’Œ qï¼Œdf f p q çš„ç»å¯¹å€¼éƒ½å°äº C

  @[simp] lemma df_eq (f : â„¤ â†’ â„¤) (p q : â„¤) :
   df f p q = f (p + q) - f (p) - f (q) := rfl

  def S := {f | almost_homo f}

  def S.add : S â†’ S â†’ S := Î» f g, âŸ¨Î» z, f.1 z + g.1 z, 
  begin
    rcases f with âŸ¨f, C1, hfâŸ©,
    rcases g with âŸ¨g, C2, hgâŸ©,
    use C1 + C2,
    intros p q,
    specialize hf p q,
    specialize hg p q,
    have h1 : df (Î» (z : â„¤), f z + g z) p q = df f p q + df g p q,
      simp,
      ring,
    rw h1,
    linarith [abs_add (df f p q) (df g p q)],
  endâŸ©

  -- #print S.add
  -- S.addçš„å¦ä¸€ç§å†™æ³•ï¼š
  def S.add2 : S â†’ S â†’ S :=
  begin
    intros f g,
    use (fun x, f.1 x + g.1 x),
    rcases f with âŸ¨f, C1, hfâŸ©,
    rcases g with âŸ¨g, C2, hgâŸ©,
    -- simp only [S,almost_homo],
    -- simp,
    use C1 + C2,
    intros p q,
    specialize hf p q,
    specialize hg p q,
    have h1 : df (Î» (z : â„¤), f z + g z) p q = df f p q + df g p q,
    { simp only [df_eq],
      ring,
    },
    rw h1,
    have h2 := abs_add (df f p q) (df g p q),-- ç»å¯¹å€¼ä¸ç­‰å¼
    linarith [h2], -- ä¸ç­‰å¼ç›¸å…³ï¼Œä¼ é€’æ€§
  end


  def S.neg : S â†’ S := Î» f, âŸ¨Î» p, - f.1 p, 
  begin
      rcases f with âŸ¨f, C1, hfâŸ©,
      use C1,
      simp,
      intros p q,
      specialize hf p q,
      simp at hf,
      have h : f p - f (p + q) + f q = - (f (p + q) - f p - f q),
        ring,
      rw [h, abs_neg],
      exact hf,
  endâŸ©

  def S.zero : S := âŸ¨Î» p, 0, 1, by norm_numâŸ©

  @[simp] lemma S.add_eq (f g : S) : S.add f g = âŸ¨Î» p, f.1 p + g.1 p, S.add._proof_1 f gâŸ© := rfl

  @[simp] lemma S.neg_eq (f : S) : S.neg f = âŸ¨Î» p, - f.1 p, S.neg._proof_1 fâŸ© := rfl

  instance add_group_S : add_group S := {
    add := Î» f g, S.add f g,
    add_assoc := begin
      intros f g h,
      simp,
      ring_nf,
    end,
    zero := âŸ¨Î» p, 0, 1, by norm_numâŸ©,
    zero_add := begin
      intro f,
      show S.add âŸ¨Î» p, 0, 1, by norm_numâŸ© f = f,
      simp,
    end,
    add_zero := begin
      intro f, 
      show S.add f âŸ¨Î» p, 0, 1, by norm_numâŸ© = f,
      simp,
    end,
    neg := Î» f, âŸ¨Î» p, - f.1 p, begin
      rcases f with âŸ¨f, C1, hfâŸ©,
      use C1,
      simp,
      intros p q,
      specialize hf p q,
      simp at hf,
      have h : f p - f (p + q) + f q = - (f (p + q) - f p - f q),
        ring,
      rw [h, abs_neg],
      exact hf,
    endâŸ©,
    add_left_neg := begin
      intro f,
      show S.add (S.neg f) f = âŸ¨Î» (p : â„¤), 0, _âŸ©,
      simp,
    end }

  @[simp] lemma S.add_eq' (f g : S) : f + g = S.add f g := rfl

  @[simp] lemma S.neg_eq' (f : S) : -f = S.neg f := rfl

  @[simp] lemma S.zero_eq' : (0 : S) = âŸ¨Î» p, 0, 1, by norm_numâŸ© := rfl

  instance : add_comm_group S := {
    add_comm := begin
      intros f g,
      show S.add f g = S.add g f,
      simp,
      simp_rw [add_comm],
    end,
    ..add_group_S }

  def B : add_subgroup S :=
  { carrier := {f : S | âˆƒ C, âˆ€ p, abs (f.1 p) < C},
    zero_mem' := begin
      use 1,
      intro p,
      norm_num,
    end,
    add_mem' := begin
      rintro f g âŸ¨C1, hfâŸ© âŸ¨C2, hgâŸ©,
      use C1 + C2,
      intro p,
      specialize hf p,
      specialize hg p,
      simp,
      change abs (f.1 p + g.1 p) < C1 + C2,
      linarith [abs_add (f.1 p) (g.1 p)],
    end,
    neg_mem' := begin
      rintro f âŸ¨C, hfâŸ©,
      use C,
      intro p,
      specialize hf p,
      change abs (-(f.val p)) < C,
      simp,
      exact hf,
    end }

  @[simp] lemma in_B_iff (f : S) : f âˆˆ B â†” âˆƒ C, âˆ€ p, abs (f.1 p) < C := iff.rfl





  -- -- ç›¸å…³å­¦ä¹ èµ„æºï¼š
  -- -- /Users/chenjulang/Desktop/æ•°å­¦/trylean/mathlib/src/linear_algebra/quotient.lean

  -- def eudoxus_reals_group := add_comm_group (S/B)
  -- -- quotient_add_group.quotient B
  -- notation `ğ”¼` := eudoxus_reals_group

  -- instance add_comm_group_ğ”¼ : add_comm_group ğ”¼ := quotient_add_group.add_comm_group B

  -- lemma lemma1 {f : â„¤ â†’ â„¤} (hf1 : almost_homo f) (hf2 : âˆ€ n (hn : 0 < n), âˆƒ p (hp : 0 < p), n < f p) :
  -- âˆ€ D, 0 < D â†’ âˆƒ M (hM : 0 < M), âˆ€ m, 0 < m â†’ (m + 1) * D < f (m * M) :=
  -- begin
  --   rcases hf1 with âŸ¨C, hf1âŸ©,
  --   intros D hD,
  --   set E := C + D with hE,
  --   have key : âˆƒ M (hM : 0 < M), 2 * E < f M,
  --     have h2E : 0 < 2 * E,
  --       linarith [hf1 0 0, abs_nonneg (df f 0 0)],
  --     rcases hf2 (2 * E) h2E with âŸ¨M, hM, HâŸ©,
  --     use [M, hM],
  --     exact H,
  --   rcases key with âŸ¨M, hM, hfMâŸ©,
  --   use [M, hM],
  --   intros m hm,
  --   have hC : 0 â‰¤ C,
  --     specialize hf1 1 2,
  --     linarith [abs_nonneg (df f 1 2)],
  --   have hED : âˆ€ k, 0 < k â†’ (k + 1) * D â‰¤ (k + 1) * E,
  --     intros k hk,
  --     rw mul_le_mul_left,
  --       linarith,
  --     linarith,
  --   apply lt_of_le_of_lt (hED m hm),
  --   induction m,
  --   { induction m with m h,
  --       exfalso,
  --       norm_num at hm,
  --     have hm0 : m = 0 âˆ¨ 0 < m,
  --       exact nat.eq_zero_or_pos m,
  --     cases hm0,
  --     { rw hm0,
  --       simp,
  --       exact hfM, },
  --     { have hm0' : int.of_nat m > 0,
  --         exact int.lt_to_nat.mp hm0,
  --       specialize h hm0',
  --       have hdf1 : f ((int.of_nat m.succ) * M) = 
  --         f (int.of_nat m * M) + f (M) + df f (int.of_nat m * M) (M),
  --         simp,
  --         ring_nf,
  --         rw mul_comm,
  --       have hdf2 : -E < df f (int.of_nat m * M) M,
  --         specialize hf1 (int.of_nat m * M) M,
  --         rw abs_lt at hf1,
  --         linarith,
  --       have h1 : (int.of_nat m + 1) * E + 2 * E + (-E) < 
  --         f (int.of_nat m * M) + f M + df f (int.of_nat m * M) M,
  --         linarith,
  --       have h2 : (int.of_nat m.succ + 1) * E = (int.of_nat m + 1) * E + 2 * E + (-E),
  --         dsimp,
  --         ring_nf,
  --         {
  --           ring,
  --         },
  --         {
  --           linarith,
  --         }
  --       }, },
  --   { exfalso,
  --     linarith [int.neg_succ_lt_zero m], },
  -- end

  -- theorem QRT : âˆ€ n m : â„¤, m > 0 â†’ âˆƒ q r : â„¤, n = m * q + r âˆ§ (0 â‰¤ r âˆ§ r < m) :=
  -- begin
  --   intros n m h,
  --   use (n / m),
  --   use (n % m),
  --   have HH:  n = m * (n / m)  + (n % m), from calc
  --     n = n % m + m * (n / m) : by rw [int.mod_add_div]
  --     ... = m * (n / m) + (n % m) : by rw add_comm,
  --   have HH1: 0 â‰¤ (n % m), from int.mod_nonneg n (ne_of_gt h),
  --   have HH2: (n % m) < m, from calc
  --     (n % m) < abs m : int.mod_lt n (ne_of_gt h)
  --     ... = m : abs_of_pos h,
  --   exact âŸ¨HH , âŸ¨HH1, HH2âŸ©âŸ©,
  -- end

  -- -- instance : has_coe_t â†¥S ğ”¼ := quotient_add_group.has_coe_t

  -- -- instance : has_lift_t â†¥S ğ”¼ := coe_to_lift

  -- -- lemma ğ”¼.zero_eq : (0 : ğ”¼) = â†‘(0 : S) := rfl

  -- -- def P := {e : ğ”¼ | âˆƒ (f : S) (H : â†‘f = e), âˆ€ n (hn : 0 < n), âˆƒ p (hp : 0 < p), n < f.1 p}

  -- -- lemma P_eq : P = {e : ğ”¼ | âˆƒ (f : S) (H : â†‘f = e), âˆ€ n (hn : 0 < n), âˆƒ p (hp : 0 < p), n < f.1 p} := rfl

  -- @[simp] lemma upper_bounds_eq {S : set â„¤} : upper_bounds S = {x : â„¤ | âˆ€ â¦ƒa : â„¤â¦„, a âˆˆ S â†’ a â‰¤ x} := rfl

  -- @[simp] lemma lower_bounds_eq {S : set â„¤} : lower_bounds S = {x : â„¤ | âˆ€ â¦ƒa : â„¤â¦„, a âˆˆ S â†’ x â‰¤ a} := rfl

  -- lemma lemma2 (f : S) (hf : âˆ€ n (hn : 0 < n), âˆƒ p (hp : 0 < p), n < f.1 p) :
  --   (âˆ€ C (HC : 0 < C), âˆƒ N : â„¤, âˆ€ p (hNp : N < p), C < f.1 p) :=
  -- begin
  --   rcases f.2 with âŸ¨D, hDâŸ©,
  --   have hD1 : âˆ€ (p q : â„¤), abs (df f.1 p q) < D := hD,
  --   specialize hD 1 2,
  --   have hD' : 0 < D,
  --     linarith [abs_nonneg (df f.1 1 2)],
  --   rcases lemma1 f.2 hf D hD' with âŸ¨M, hM0, hMâŸ©,
  --   have hE : âˆƒ E, âˆ€ r (h0r : 0 â‰¤ r) (hrM : r < M), abs(f.1 r) < E,
  --     have hfin : set.finite ((abs âˆ˜ f.1) '' (set.Ico 0 M)),
  --       apply set.finite.image,
  --       split,
  --       apply fintype.of_finset (Ico (0:â„¤) M),
  --       simp,
  --     have hbdd : bdd_above ((abs âˆ˜ f.1) '' (set.Ico 0 M)),
  --       apply set.finite.bdd_above hfin,
  --     cases hbdd with m hm,
  --     simp at hm,
  --     use m + 1,
  --     intros r h0r hrM,
  --     specialize @hm (abs (f.1 r)) r h0r hrM rfl,
  --     linarith,
  --   cases hE with E hE,
  --   have hE1 : âˆ€ (r : â„¤), 0 â‰¤ r â†’ r < M â†’ abs (f.1 r) < E := hE,
  --   specialize hE 0 _ _,
  --   { set B := E + D with hB,
  --     intros C hC,
  --     have hBC0 : 0 < B + C,
  --       linarith [abs_nonneg (f.1 0)],
  --     have hn : âˆƒ n (hn0 : n > 0), B + C < (n + 1) * D,
  --       rcases (QRT (B + C) D hD') with âŸ¨n, r, hnr, h0r, hrDâŸ©,
  --       rw hnr at hBC0,
  --       have h0n : 0 â‰¤ n,
  --         by_contradiction hfalse,
  --         simp at hfalse,
  --         have hnn : âˆƒ (nn : â„¤) (hnn0 : nn > 0), n = -nn,
  --           use -n,
  --           split,
  --             linarith,
  --           simp,
  --         rcases hnn with âŸ¨nn, hnn0, hnnâŸ©,
  --         rw hnn at hBC0,
  --         have hDnnr : D * nn â‰¤ r,
  --           linarith,
  --         have hDDnn : D â‰¤ D * nn,
  --           exact (le_mul_iff_one_le_right hD').mpr (show nn â‰¥ 1, by linarith),
  --         linarith,
  --       use n + 1,
  --       split,
  --         linarith,
  --       have hfinal : (n + 1 + 1) * D = D * n + 2 * D,
  --         ring,
  --       rw hfinal,
  --       linarith,
  --     rcases hn with âŸ¨n, hn0, hnâŸ©,
  --     use n * M,
  --     intros p hp,
  --     rcases (QRT p M hM0) with âŸ¨d, r, hdr, h0r, hrMâŸ©,
  --     rw hdr at hp,
  --     have hndr : (n - d) * M < M,
  --       linarith,
  --     have hnd : n - d < 1,
  --       exact (mul_lt_iff_lt_one_left hM0).mp hndr,
  --     have hnd' : n â‰¤ d,
  --       linarith,
  --     have hd0 : 0 < d,
  --       linarith,
  --     have hfdm1 : B + C < f.1 (d * M),
  --       have hnDdD1 : n + 1 â‰¤ d + 1,
  --         linarith,
  --       have hnDdD2 : (n + 1) * D â‰¤ (d + 1) * D,
  --         exact (mul_le_mul_right hD').mpr hnDdD1,
  --       linarith [hM d hd0],
  --     have hfdMr : abs (f.1 p - f.1 (d * M)) < B,
  --       rw hdr,
  --       have heq1 : f.1 (M * d + r) = f.1 (M * d) + f.1 (r) + df f.1 (M * d) r,
  --         simp,
  --         ring,
  --       have heq2 : f.1 (d * M) + f.1 r + df f.1 (d * M) r - f.1 (d * M) = f.1 r + df f.1 (d * M) r,
  --         ring,
  --       rw [heq1, mul_comm, heq2],
  --       linarith [hD1 (d * M) r, hE1 r h0r hrM, abs_add (f.1 r) (df f.1 (d * M) r)],
  --     rw abs_lt at hfdMr,
  --     linarith, },
  --   { refl, },
  --   { exact hM0, },
  -- end

  -- lemma lemma3 (f : S) (hf : âˆ€ n (hn : n < 0), âˆƒ p (hp : 0 < p), f.1 p < n) :
  --   (âˆ€ C (HC : 0 < C), âˆƒ N : â„¤, âˆ€ p (hNp : N < p), f.1 p < -C) := 
  -- begin
  --   set g := -f with hgf,
  --   have hfval : âˆ€ p, (-f).val p = -(f.val p),
  --     intro p,
  --     refl,
  --   have key : âˆ€ (C : â„¤), 0 < C â†’ (âˆƒ (N : â„¤), âˆ€ (p : â„¤), N < p â†’ C < g.val p),
  --     apply lemma2 g,
  --     simp_rw [hgf, hfval],
  --     intros n hn,
  --     have : -n < 0,
  --       linarith,
  --     specialize hf (-n) this,
  --     rcases hf with âŸ¨p, hp, hfâŸ©,
  --     use [p, hp],
  --     linarith,
  --   simp_rw [hgf, hfval] at key,
  --   rintro C hC,
  --   specialize key C hC,
  --   cases key with N key,
  --   use N,
  --   intros p hp,
  --   specialize key p hp,
  --   linarith,
  -- end

  -- lemma lemma4 (f : S) (hf : âˆƒ C, âˆ€ p (hp : 0 â‰¤ p), abs (f.1 p) < C) : âˆƒ B, âˆ€ p, abs (f.1 p) < B :=
  -- begin
  --   cases f.2 with D hD,
  --   cases hf with C hC,
  --   have hneg : âˆƒ C', âˆ€ p (hp : p < 0), abs (f.1 p) < C',
  --     use C + D + abs (f.1 0),
  --     intros p hp,
  --     have hfp : f.1 p = f.1 0 - f.1 (-p) - df f.1 (-p) p,
  --       simp,
  --       ring_nf,
  --     rw hfp,
  --     have hnegp : 0 < -p,
  --       exact neg_pos.mpr hp,
  --     have hnegp' : 0 â‰¤ -p,
  --       linarith,
  --     specialize hC (-p) hnegp',
  --     specialize hD (-p) p,
  --     have heq : f.val 0 - f.val (-p) - df f.val (-p) p = f.val 0 + (-f.val (-p)) + (-df f.val (-p) p),
  --       ring,
  --     rw heq,
  --     have habs3 : abs (f.val 0 + -f.val (-p) + -df f.val (-p) p) â‰¤ 
  --       abs (f.val 0) + abs (-f.val (-p)) + abs (-df f.val (-p) p),
  --       exact abs_add_three (f.val 0) (-f.val (-p)) (-df f.val (-p) p),
  --     rw [abs_neg, abs_neg] at habs3,
  --     linarith [abs_add_three (f.val 0) (-f.val (-p)) (-df f.val (-p) p)],
  --   cases hneg with C' hC',
  --   use C + C',
  --   intro p,
  --   have hp : 0 â‰¤ p âˆ¨ p < 0 := le_or_lt 0 p,
  --   cases hp,
  --   { specialize hC p hp,
  --     have hne1 : (-1 : â„¤) < 0,
  --       norm_num,
  --     specialize hC' (-1) hne1,
  --     linarith [abs_nonneg (f.val (-1))], },
  --   { specialize hC' p hp,
  --     have h01 : (0 : â„¤) â‰¤ 1,
  --       norm_num,
  --     specialize hC 1 h01,
  --     linarith [abs_nonneg (f.val 1)], },
  -- end

  -- lemma lemma5 (f : S) : (âˆ€ n (hn : 0 < n), âˆƒ p (hp : 0 < p), n < f.1 p) âˆ¨ 
  --   (âˆ€ n (hn : n < 0), âˆƒ p (hp : 0 < p), f.1 p < n) âˆ¨ (âˆƒ C, âˆ€ p (hp : 0 â‰¤ p), abs (f.1 p) < C) :=
  -- begin
  --   by_cases h1 : âˆ€ n (hn : 0 < n), âˆƒ p (hp : 0 < p), n < f.1 p,
  --     left,
  --     exact h1,
  --   by_cases h2 : âˆ€ n (hn : n < 0), âˆƒ p (hp : 0 < p), f.1 p < n,
  --     right,
  --     left,
  --     exact h2,
  --   have h1' : âˆƒ n (hn : 0 < n), âˆ€ p (hp : 0 < p), f.1 p â‰¤ n,
  --     finish,
  --   have h2' : âˆƒ n (hn : n < 0), âˆ€ p (hp : 0 < p), n â‰¤ f.1 p,
  --     finish,  
  --   rcases h1' with âŸ¨C1, hC1, h1'âŸ©,
  --   rcases h2' with âŸ¨C2, hC2, h2'âŸ©,
  --   right,
  --   right,
  --   use abs (C1) + abs (C2) + abs (f.val 0) + 1,
  --   intros p hp,
  --   have hfval0 : 0 < f.1 p âˆ¨ f.1 p â‰¤ 0,
  --     exact lt_or_ge 0 (f.val p),
  --   cases hfval0,
  --   { have habs : abs (f.val p) â‰¤ abs C1 + abs (f.val 0),
  --       have := eq_or_lt_of_le hp,
  --       cases this,
  --         rw â† this,
  --         linarith [abs_nonneg C1],
  --       specialize h1' p this,
  --       have : abs (f.val p) â‰¤ abs C1,
  --         apply abs_le_abs h1',
  --         linarith,
  --       linarith [abs_nonneg (f.val 0)],
  --     linarith [abs_nonneg C2], },
  --   { have hfval0' : f.1 p < 0 âˆ¨ f.1 p = 0,
  --       exact lt_or_eq_of_le hfval0,
  --     cases hfval0',
  --     { have habs : abs (f.val p) â‰¤ abs C2 + abs (f.val 0),
  --         have := eq_or_lt_of_le hp,
  --         cases this,
  --           rw â† this,
  --           linarith [abs_nonneg C2],
  --         specialize h2' p this,
  --         have habs : abs (f.val p) â‰¤ abs C2,
  --           rw abs_of_neg hfval0',
  --           have hC2 : C2 < 0,
  --             linarith,
  --           rw abs_of_neg hC2,
  --           linarith,
  --         linarith [abs_nonneg (f.val 0)],
  --       linarith [abs_nonneg C1], }, 
  --     { rw hfval0',
  --       simp only [abs_zero],
  --       linarith [abs_nonneg C1, abs_nonneg C2, abs_nonneg (f.1 0)], }, },
  -- end

  -- lemma lemma6 (f : S) : (âˆ€ C (HC : 0 < C), âˆƒ N : â„¤, âˆ€ p (hNp : N < p), C < f.1 p) âˆ§ 
  --   (âˆ€ C (HC : 0 < C), âˆƒ N : â„¤, âˆ€ p (hNp : N < p), f.1 p < -C) â†’ false :=
  -- begin
  --   rintro âŸ¨h1, h2âŸ©,
  --   have h01 : (0 : int) < 1,
  --     norm_num,
  --   specialize h1 1 h01,
  --   specialize h2 1 h01,
  --   cases h1 with N1 h1,
  --   cases h2 with N2 h2,
  --   have hN1 : N1 < abs N1 + abs N2 + 1,
  --     linarith [abs_nonneg N2, le_abs_self N1],
  --   have hN2 : N2 < abs N1 + abs N2 + 1,
  --     linarith [abs_nonneg N1, le_abs_self N2],
  --   specialize h1 (abs N1 + abs N2 + 1) hN1,
  --   specialize h2 (abs N1 + abs N2 + 1) hN2,
  --   linarith,
  -- end

  -- lemma lemma7 (f : S) : (âˆ€ C (HC : 0 < C), âˆƒ N : â„¤, âˆ€ p (hNp : N < p), C < f.1 p) âˆ§ 
  --   (âˆƒ B, âˆ€ p, abs (f.1 p) < B) â†’ false :=
  -- begin
  --   rintro âŸ¨h1, h2âŸ©,
  --   cases h2 with B h2,
  --   have h01 : (0 : int) < 1,
  --     norm_num,
  --   have h2' : âˆ€ (p : â„¤), abs (f.val p) < B := h2,
  --   specialize h2' 0,
  --   have hB : 0 < B,
  --     linarith [abs_nonneg (f.1 0)],
  --   specialize h1 B hB,
  --   cases h1 with N h1,
  --   have hN : N < N + 1,
  --     linarith,
  --   specialize h1 (N + 1) hN,
  --   specialize h2 (N + 1),
  --   rw abs_lt at h2,
  --   linarith,
  -- end

  -- lemma lemma8 (f : S) : (âˆ€ n (hn : 0 < n), âˆƒ p (hp : 0 < p), n < f.1 p) â†”
  --   (âˆ€ C (HC : 0 < C), âˆƒ N : â„¤, âˆ€ p (hNp : N < p), C < f.1 p) :=
  -- begin
  --   split,
  --   { intro hf,
  --     exact lemma2 f hf, },
  --   { cases lemma5 f,
  --     { intro,
  --       exact h, },
  --     { cases h,
  --       { intro h1,
  --         exfalso,
  --         exact lemma6 f âŸ¨h1, lemma3 f hâŸ©, },
  --       { intro h1,
  --         exfalso,
  --         exact lemma7 f âŸ¨h1, lemma4 f hâŸ©, }, }, },
  -- end

  -- lemma lemma9 : âˆ€ a b âˆˆ P, a + b âˆˆ P :=
  -- begin
  --   rintro a b âŸ¨f1, hf1a, h1âŸ© âŸ¨f2, hf2b, h2âŸ©,
  --   use f1 + f2,
  --   split,
  --     rw [â† hf1a, â† hf2b],
  --     refl,
  --   rw lemma8 at *,
  --   intros C hC,
  --   specialize h1 C hC,
  --   specialize h2 C hC,
  --   cases h1 with M h1,
  --   cases h2 with N h2,
  --   use max M N,
  --   intro p,
  --   intro hMNp,
  --   have hMNp': M < p âˆ§ N < p,
  --     rw â† max_lt_iff,
  --     exact hMNp,
  --   specialize h1 p hMNp'.1,
  --   specialize h2 p hMNp'.2,
  --   have hfinal : (f1 + f2).val p = f1.val p + f2.val p,
  --     refl,
  --   rw hfinal,
  --   linarith,
  -- end

  -- lemma lemma10 : (0 : ğ”¼) âˆˆ P â†’ false :=
  -- begin
  --   intro hfalse,
  --   rw P_eq at hfalse,
  --   rcases hfalse with âŸ¨f, H, hfalseâŸ©,
  --   rw lemma8 at hfalse,
  --   rw ğ”¼.zero_eq at H,
  --   rw quotient_add_group.eq at H,
  --   simp at H,
  --   exact lemma7 f âŸ¨hfalse, HâŸ©,
  -- end

  -- lemma lemma11 {a : ğ”¼} : a âˆˆ P â†’ -a âˆˆ P â†’ false :=
  -- begin
  --   rw P_eq,
  --   rintro âŸ¨f1, hf1, ha1âŸ© âŸ¨f2, hf2, ha2âŸ©,
  --   rw â† hf1 at hf2,
  --   have hf1f2 : â†‘f2 + â†‘f1 = (0 : ğ”¼), 
  --     rw hf2,
  --     simp,
  --   have hf1f2' : (@coe â†¥S ğ”¼) eudoxus_reals_group.has_lift_t (0 : S) = â†‘(f2 + f1), 
  --     have heq : (@coe â†¥S ğ”¼) eudoxus_reals_group.has_lift_t (f2 + f1) = â†‘f2 + â†‘f1,
  --       refl,
  --     have h0 : (@coe â†¥S ğ”¼) eudoxus_reals_group.has_lift_t (0 : S) = (0 : ğ”¼),
  --       refl,
  --     rw [heq, h0, â† hf1f2],
  --   rw quotient_add_group.eq at hf1f2',
  --   simp only [nonempty_of_inhabited, sub_zero, abs_zero, S.neg_eq', zero_add, df_eq, S.neg_eq,
  --     in_B_iff, neg_zero] at hf1f2',
  --   cases hf1f2' with C hf1f2',
  --   rw lemma8 at *,
  --   have h0C : 0 < C,
  --     linarith [hf1f2' 0, abs_nonneg ((f2 + f1).val 0)],
  --   cases ha1 C h0C with N1 ha1,
  --   cases ha2 C h0C with N2 ha2,
  --   have hN1 : N1 < max N1 N2 + 1,
  --     linarith [le_max_left N1 N2],
  --   have hN2 : N2 < max N1 N2 + 1,
  --     linarith [le_max_right N1 N2],
  --   specialize ha1 (max N1 N2 + 1) hN1,
  --   specialize ha2 (max N1 N2 + 1) hN2,
  --   specialize hf1f2' (max N1 N2 + 1),
  --   have heq : (f2 + f1).val (max N1 N2 + 1) = f2.val (max N1 N2 + 1) + f1.val (max N1 N2 + 1) := rfl,
  --   rw [heq, abs_lt] at hf1f2',
  --   linarith,
  -- end

  -- lemma lemma12 : âˆ€ a : ğ”¼, âˆƒ f : S, â†‘f = a := Î» a, quot.exists_rep a

  -- lemma lemma13 : âˆ€ {f : â„¤ â†’ â„¤} (C : â„¤), set.finite (f '' (set.Ioo (-C) C)) :=
  -- begin
  --   intros f C,
  --   apply set.finite.image,
  --   exact âŸ¨fintype.of_finset (finset.Ico_â„¤ (-C + 1) (C)) (by {simp [int.add_one_le_iff]})âŸ©,
  -- end

  -- lemma lemma14 : âˆ€ f g : S, f.1 âˆ˜ g.1 âˆˆ S :=
  -- begin
  --   intros f g,
  --   rcases f with âŸ¨f, C1, hfâŸ©,
  --   rcases g with âŸ¨g, C2, hgâŸ©,
  --   simp,
  --   have hfin : set.finite (f '' (set.Ioo (-C2) (C2))) := lemma13 C2,
  --   cases set.finite.bdd_above hfin with C3 hC3,
  --   simp at hC3,
  --   cases set.finite.bdd_below hfin with C4 hC4,
  --   simp at hC4,
  --   use C1 + C1 + max (abs (C4)) (abs (C3)),
  --   simp_rw df_eq at *,
  --   intros p q,
  --   have hf' := hf,
  --   set t := g (p + q) - g p - g q with ht,
  --   have heq : g (p + q) = t + (g p + g q),
  --     rw ht,
  --     ring,
  --   specialize hf (g p) (g q),
  --   specialize hg p q,
  --   specialize hf' t (g p + g q),
  --   rw [â† ht, abs_lt] at hg,
  --   specialize @hC3 (f t) t hg.1 hg.2 rfl,
  --   specialize @hC4 (f t) t hg.1 hg.2 rfl,
  --   rw â† heq at hf',
  --   have h123 : abs ((f (g p + g q) - f (g p) - f (g q)) + (f (g (p + q)) - f t - f (g p + g q)) + f t)
  --     â‰¤ abs (f (g p + g q) - f (g p) - f (g q)) + abs (f (g (p + q)) - f t - f (g p + g q)) + abs (f t),
  --     exact abs_add_three (f (g p + g q) - f (g p) - f (g q)) (f (g (p + q)) - f t - f (g p + g q)) (f t),
  --   have heq : (f (g p + g q) - f (g p) - f (g q)) + (f (g (p + q)) - f t - f (g p + g q)) + f t = 
  --     (f âˆ˜ g) (p + q) - (f âˆ˜ g) p - (f âˆ˜ g) q,
  --     ring,
  --   rw heq at h123,
  --   have hft : abs (f t) â‰¤ max (abs (C4)) (abs (C3)),
  --     apply abs_le_max_abs_abs hC4 hC3,
  --   linarith,
  -- end

  -- lemma lemma15 : âˆ€ {f1 g1 f2 g2 : S}, (@coe â†¥S ğ”¼) eudoxus_reals_group.has_lift_t f1 = â†‘f2 â†’ 
  --   (@coe â†¥S ğ”¼) eudoxus_reals_group.has_lift_t g1 = â†‘g2 â†’ -(âŸ¨f1.1 âˆ˜ g1.1, lemma14 f1 g1âŸ© : S) 
  --   + (âŸ¨f2.1 âˆ˜ g2.1, lemma14 f2 g2âŸ© : S) âˆˆ B :=
  -- begin
  --   rintros âŸ¨f1, hf1âŸ© âŸ¨g1, hfgâŸ© âŸ¨f2, Bf2, hf2âŸ© âŸ¨g2, hg2âŸ© hf1f2 hg1g2,
  --   rw quotient_add_group.eq at *,
  --   cases hf1f2 with Cf hf1f2,
  --   cases hg1g2 with Cg hg1g2,
  --   have hfin : set.finite (f2 '' (set.Ioo (-Cg) (Cg))) := lemma13 Cg,
  --   cases set.finite.bdd_above hfin with C3 hC3,
  --   simp at hC3,
  --   cases set.finite.bdd_below hfin with C4 hC4,
  --   simp at hC4,
  --   use Cf + Bf2 + max (abs (C4)) (abs (C3)),
  --   simp_rw df_eq at hf2,
  --   intros x,
  --   set t := -g1 x + g2 x with ht,
  --   have heq : g2 x = t + g1 x,
  --     rw ht,
  --     ring,
  --   specialize hf1f2 (g1 x),
  --   specialize hg1g2 x,
  --   specialize hf2 t (g1 x),
  --   simp at hf1f2,
  --   simp at hg1g2,
  --   rw [â† ht, abs_lt] at hg1g2,
  --   specialize @hC3 (f2 t) t hg1g2.1 hg1g2.2 rfl,
  --   specialize @hC4 (f2 t) t hg1g2.1 hg1g2.2 rfl,
  --   rw â† heq at hf2,
  --   simp,
  --   have h123 := abs_add_three (-(f1 (g1 x))+ f2 (g1 x)) (f2 (g2 x) - f2 t - f2 (g1 x)) (f2 t),
  --   have heq : (-(f1 (g1 x)) + f2 (g1 x)) + (f2 (g2 x) - f2 t - f2 (g1 x)) + f2 t = 
  --     -(f1 (g1 x)) + f2 (g2 x),
  --     ring,
  --   rw heq at h123,
  --   have hft : abs (f2 t) â‰¤ max (abs (C4)) (abs (C3)),
  --     apply abs_le_max_abs_abs hC4 hC3,
  --   linarith,
  -- end

  -- lemma lemma16 : (id : â„¤ â†’ â„¤) âˆˆ S := 
  -- begin
  --   use 1,
  --   intros p q,
  --   norm_num,
  -- end

  -- noncomputable def ğ”¼.mul : ğ”¼ â†’ ğ”¼ â†’ ğ”¼ := Î» a b, 
  -- begin
  --   choose f hf using lemma12 a,
  --   choose g hg using lemma12 b,
  --   let h : â†¥S := âŸ¨f.1 âˆ˜ g.1, lemma14 f gâŸ©,
  --   exact â†‘h,
  -- end

  -- @[simp] lemma ğ”¼.mul_eq (a b : ğ”¼) : ğ”¼.mul a b = (begin
  --   choose f hf using lemma12 a,
  --   choose g hg using lemma12 b,
  --   let h : â†¥S := âŸ¨f.1 âˆ˜ g.1, lemma14 f gâŸ©,
  --   exact â†‘h,
  -- end : ğ”¼) := rfl

  -- -- lemma lemma17 : âˆ€ x y : S, ğ”¼.mul â†‘x â†‘y = â†‘(âŸ¨x.1 âˆ˜ y.1, lemma14 x yâŸ© : S) :=
  -- -- begin
  -- --   intros x y,
  -- --   simp,
  -- --   rw quotient_add_group.eq,
  -- --   have hxeq := classical.some_spec (lemma12 â†‘x),
  -- --   have hyeq := classical.some_spec (lemma12 â†‘y),
  -- --   apply lemma15 hxeq hyeq,
  -- -- end

  -- lemma lemma18 : âˆ€ x y : S, x = y â†’ -x + y âˆˆ B :=
  -- begin
  --   intros x y hxy,
  --   rw hxy,
  --   simp,
  --   use 1,
  --   norm_num,
  -- end

  -- lemma lemma19 (f : S) : âˆƒ C, âˆ€ p (H : 0 â‰¤ p) q, abs (f.1 (p * q) - p * (f.1 q)) < (abs p + 1) * C :=
  -- begin
  --   cases f.2 with C hC,
  --   use C,
  --   intros p H,
  --   induction p,
  --   { induction p with p hp,
  --     { intro q,
  --       simp,
  --       change abs (f.1 0) < C,
  --       have hf0 : abs (f.1 0) = abs (f.1 (0 + 0) - f.1 0 - f.1 0),
  --         simp,
  --       have hdf0 : df f.1 0 0 = f.1 (0 + 0) - f.1 0 - f.1 0 := rfl,
  --       rw [hf0, â† hdf0],
  --       exact hC 0 0, },
  --     { intro q,
  --       specialize hp (int.of_nat_nonneg p) q,
  --       have hkey : f.val (int.of_nat p.succ * q) - f.1 (p * q) - f.1 q = df f.1 (p * q) q,
  --         simp,
  --         ring,
  --       specialize hC (p * q) q,
  --       rw â† hkey at hC,
  --       have heq : f.val (int.of_nat p.succ * q) - int.of_nat p.succ * f.val q = 
  --         (f.val (int.of_nat p.succ * q) - f.val (â†‘p * q) - f.val q) + (f.val (int.of_nat p * q) - 
  --         int.of_nat p * f.val q),
  --         simp,
  --         ring,
  --       rw heq,
  --       have : (abs (int.of_nat p.succ) + 1) * C = C + (abs (int.of_nat p) + 1) * C,
  --         have hp1 : 0 < (â†‘p : â„¤) + 1,
  --           linarith,
  --         simp,
  --         rw [abs_of_pos hp1],
  --         ring,
  --       linarith [abs_add (f.val (int.of_nat p.succ * q) - f.val (â†‘p * q) - f.val q) (f.val (int.of_nat p * q) - 
  --         int.of_nat p * f.val q)], }, },
  --     { exfalso,
  --       linarith [int.neg_succ_lt_zero p], },
  -- end

  -- lemma lemma20 (f : S) : âˆƒ C, âˆ€ p (H : 0 â‰¤ p) q, abs (f.1 ((-p) * q) - (-p) * (f.1 q)) < (abs (-p) + 1) * C :=
  -- begin
  --   cases f.2 with C hC,
  --   use C,
  --   intros p H,
  --   induction p,
  --   { induction p with p hp,
  --     { intro q,
  --       simp,
  --       change abs (f.1 0) < C,
  --       have hf0 : abs (f.1 0) = abs (f.1 (0 + 0) - f.1 0 - f.1 0),
  --         simp,
  --       have hdf0 : df f.1 0 0 = f.1 (0 + 0) - f.1 0 - f.1 0 := rfl,
  --       rw [hf0, â† hdf0],
  --       exact hC 0 0, },
  --     { intro q,
  --       specialize hp (int.of_nat_nonneg p) q,
  --       have hkey : -f.1 (-int.of_nat p.succ * q) + f.1 (-(p * q)) - f.1 q = df f.1 (-(p + 1) * q) q,
  --         simp,
  --         have heq : (-1 + -â†‘p) * q + q = -(â†‘p * q),
  --           ring,
  --         rw heq,
  --         ring,
  --       specialize hC (-(â†‘p + 1) * q) q,
  --       rw â† hkey at hC,
  --       have heq : f.val (-int.of_nat p.succ * q) - -int.of_nat p.succ * f.val q = 
  --         -(-f.val (-int.of_nat p.succ * q) + f.val (-(p * q)) - f.val q) + (f.val (-int.of_nat p * q) - 
  --         -int.of_nat p * f.val q),
  --         simp,
  --         ring,
  --       rw heq,
  --       have : (abs (-int.of_nat p.succ) + 1) * C = C + (abs (-int.of_nat p) + 1) * C,
  --         have hp1 : 0 â‰¤ (â†‘p : â„¤) := int.of_nat_nonneg p,
  --         have hp2 : -1 + -(â†‘p : â„¤) < 0,
  --           linarith,
  --         simp,
  --         rw [abs_of_neg hp2],
  --         ring,
  --       have := abs_add (-(-f.val (-int.of_nat p.succ * q) + f.val (-(p * q)) - f.val q)) (f.val (-int.of_nat p * q) - 
  --         -int.of_nat p * f.val q),
  --       rw abs_neg at this,
  --       linarith, }, },
  --     { exfalso,
  --       linarith [int.neg_succ_lt_zero p], },
  -- end

  -- lemma lemma21 (f : S) : âˆƒ C, âˆ€ p q,  abs (f.1 (p * q) - p * (f.1 q)) < (abs p + 1) * C :=
  -- begin
  --   cases lemma19 f with C1 hC1,
  --   cases lemma20 f with C2 hC2,
  --   use max C1 C2,
  --   intro p,
  --   have hp0 := le_or_lt 0 p,
  --   cases hp0,
  --   { intro q,
  --     specialize hC1 p hp0 q,
  --     have := le_max_left C1 C2,
  --     have h0abs : 0 < abs p + 1,
  --       linarith [abs_nonneg p],
  --     have : (abs p + 1) * C1 â‰¤ (abs p + 1) * max C1 C2,
  --       have := @mul_le_mul_left â„¤ (linear_ordered_ring.to_linear_ordered_semiring) C1 (max C1 C2) (abs p + 1),
  --       rw this,
  --         exact le_max_left C1 C2,
  --       linarith,
  --     linarith, },
  --   { intro q,
  --     set np := -p with hnp,
  --     have hnp0 : 0 â‰¤ np,
  --       linarith,
  --     specialize hC2 np hnp0 q,
  --     have hnpp : -np = p,
  --       rw hnp,
  --       simp,
  --     rw hnpp at hC2,
  --     have := le_max_left C1 C2,
  --     have h0abs : 0 < abs p + 1,
  --       linarith [abs_nonneg p],
  --     have : (abs p + 1) * C2 â‰¤ (abs p + 1) * max C1 C2,
  --       have := @mul_le_mul_left â„¤ (linear_ordered_ring.to_linear_ordered_semiring) C2 (max C1 C2) (abs p + 1),
  --       rw this,
  --         exact le_max_right C1 C2,
  --       linarith,
  --     linarith, },
  -- end

  -- lemma lemma22 (f : S) : âˆƒ C, âˆ€ p q, abs (p * (f.1 q) - q * (f.1 p)) < (abs p + abs q + 2) * C :=
  -- begin
  --   cases lemma21 f with C hC,
  --   use C,
  --   intros p q,
  --   have hC' := hC,
  --   specialize hC p q,
  --   specialize hC' q p,
  --   rw â† abs_neg at hC,
  --   have heq1 : (-(f.val (p * q) - p * f.val q)) + (f.val (q * p) - q * f.val p) = p * f.val q - q * f.val p,
  --     rw mul_comm,
  --     ring,
  --   have heq2 : (abs p + abs q + 2) * C = ((abs p + 1) * C) + ((abs q + 1) * C),
  --     ring,
  --   rw [â† heq1, heq2],
  --   linarith [abs_add (-(f.val (p * q) - p * f.val q)) (f.val (q * p) - q * f.val p)],
  -- end

  -- lemma lemma23 (f : S) : âˆƒ A B (hA : 0 < A), âˆ€ p, abs (f.1 p) < A * abs p + B :=
  -- begin
  --   cases lemma22 f with C hC,
  --   have hC0 : 0 < C + abs (f.1 1),
  --     specialize hC 0 0,
  --     simp at hC,
  --     linarith [abs_nonneg (f.1 1)],
  --   use [C + abs (f.1 1), 3 * C, hC0],
  --   intro p,
  --   specialize hC p 1,
  --   have heq1 : f.1 p = -(p * f.1 1 - f.1 p) + (p * f.1 1),
  --     ring,
  --   have heq2 : (C + abs (f.val 1)) * abs p + 3 * C = (abs p + 1 + 2) * C + abs (p * f.1 1),
  --     have : abs (p * f.1 1) = (abs p) * abs (f.1 1) := abs_mul p (f.1 1),
  --     rw this,
  --     ring,
  --   rw [heq1, heq2],
  --   simp at hC,
  --   change abs (p * f.1 1 - f.1 p) < (abs p + 1 + 2) * C at hC,
  --   rw â† abs_neg at hC,
  --   linarith [abs_add (-(p * f.val 1 - f.val p)) (p * f.1 1)],
  -- end

  -- lemma lemma24 (f g : S) : âˆƒ D E, âˆ€ p, abs p * abs (f.1 (g.1 p) - g.1 (f.1 p)) < D * abs p + E :=
  -- begin
  --   have h1 : âˆƒ C, âˆ€ p, abs (p * f.1 (g.1 p) - g.1 p * f.1 p) < (abs p + abs (g.1 p) + 2) * C,
  --     cases lemma22 f with C hC,
  --     use C,
  --     intro p,
  --     specialize hC p (g.1 p),
  --     exact hC,
  --   have h2 : âˆƒ C, âˆ€ p, abs (g.1 p * f.1 p - p * g.1 (f.1 p)) < (abs p + abs (f.1 p) + 2) * C,
  --     cases lemma22 g with C hC,
  --     use C,
  --     intro p,
  --     specialize hC p (f.1 p),
  --     have heq : p * g.val (f.val p) - f.val p * g.val p = -(g.val p * f.val p - p * g.val (f.val p)),
  --       ring,
  --     rw [heq, abs_neg] at hC,
  --     exact hC,
  --   have h3 : âˆƒ C, âˆ€ p, abs (p * f.1 (g.1 p) - p * g.1 (f.1 p)) < (2 * abs p + abs (g.1 p) + abs (f.1 p) + 4) * C,
  --     cases h1 with C1 h1,
  --     cases h2 with C2 h2,
  --     use max C1 C2,
  --     intro p,
  --     specialize h1 p,
  --     specialize h2 p,
  --     have h0abs1 : 0 < abs p + abs (g.val p) + 2,
  --       linarith [abs_nonneg p, abs_nonneg (g.val p)],
  --     have h0abs2 : 0 < abs p + abs (f.val p) + 2,
  --       linarith [abs_nonneg p, abs_nonneg (f.val p)],
  --     have : (abs p + abs (g.val p) + 2) * C1 â‰¤ (abs p + abs (g.val p) + 2) * max C1 C2,
  --       have := @mul_le_mul_left â„¤ (linear_ordered_ring.to_linear_ordered_semiring) C1 (max C1 C2) (abs p + abs (g.val p) + 2),
  --       rw this,
  --         exact le_max_left C1 C2,
  --       linarith,
  --     have : (abs p + abs (f.val p) + 2) * C2 â‰¤ (abs p + abs (f.val p) + 2) * max C1 C2,
  --       have := @mul_le_mul_left â„¤ (linear_ordered_ring.to_linear_ordered_semiring) C2 (max C1 C2) (abs p + abs (f.val p) + 2),
  --       rw this,
  --         exact le_max_right C1 C2,  
  --       linarith,    
  --     have heq1 : (2 * abs p + abs (g.val p) + abs (f.val p) + 4) * max C1 C2 = 
  --       (abs p + abs (g.val p) + 2) * max C1 C2 + (abs p + abs (f.val p) + 2) * max C1 C2,
  --       ring,
  --     have heq2 : p * f.val (g.val p) - p * g.val (f.val p) = (p * f.1 (g.1 p) - g.1 p * f.1 p) +
  --       (g.1 p * f.1 p - p * g.1 (f.1 p)),
  --       ring,
  --     rw [heq1, heq2],
  --     linarith [abs_add (p * f.1 (g.1 p) - g.1 p * f.1 p) (g.1 p * f.1 p - p * g.1 (f.1 p))],
  --   cases h3 with C h3,
  --   rcases lemma23 f with âŸ¨Af, Bf, hAf, hABfâŸ©,
  --   rcases lemma23 g with âŸ¨Ag, Bg, hAg, hABgâŸ©,  
  --   have h4 : âˆ€ (p : â„¤), abs (p * f.val (g.val p) - p * g.val (f.val p)) < 
  --     (2 * abs p + (Ag * abs p + Bg) + (Af * abs p + Bf) + 4) * C,
  --     intro p,
  --     specialize hABf p,
  --     specialize hABg p,
  --     specialize h3 p,
  --     have h0abs : 0 < (2 * abs p + abs (g.val p) + abs (f.val p) + 4),
  --       linarith [abs_nonneg p, abs_nonneg (g.val p), abs_nonneg (f.val p)],
  --     have : (2 * abs p + abs (g.val p) + abs (f.val p) + 4) * C < 
  --       (2 * abs p + (Ag * abs p + Bg) + (Af * abs p + Bf) + 4) * C,
  --       have hfvalgval : (2 * abs p + abs (g.val p) + abs (f.val p) + 4) < 
  --         (2 * abs p + (Ag * abs p + Bg) + (Af * abs p + Bf) + 4),
  --         linarith,
  --       apply mul_lt_mul hfvalgval (le_refl C),
  --         have := abs_nonneg (p * f.val (g.val p) - p * g.val (f.val p)),
  --         have h0mul : 0 < (2 * abs p + abs (g.val p) + abs (f.val p) + 4) * C,
  --           linarith,
  --         have : 0 < C,
  --           exact (zero_lt_mul_left h0abs).mp h0mul,
  --         linarith,
  --       linarith, 
  --     linarith,
  --   use [(2 + Ag + Af) * C, (Bg + Bf + 4) * C],
  --   intro p,
  --   specialize h4 p,
  --   have heq1 : (2 * abs p + (Ag * abs p + Bg) + (Af * abs p + Bf) + 4) * C = 
  --     (2 * abs p + (Ag * abs p + Bg) + (Af * abs p + Bf) + 4) * C,
  --     ring,
  --   have heq2 : abs p * abs (f.val (g.val p) - g.val (f.val p)) = 
  --     abs (p * f.val (g.val p) - p * g.val (f.val p)),
  --     have := (abs_mul p (f.val (g.val p) - g.val (f.val p))).symm,
  --     convert this,
  --     ring,
  --   linarith,
  -- end

  -- lemma lemma25 (f g : S) : -(âŸ¨f.1 âˆ˜ g.1, lemma14 f gâŸ© : S) + (âŸ¨g.1 âˆ˜ f.1, lemma14 g fâŸ© : S) âˆˆ B :=
  -- begin
  --   rcases lemma24 f g with âŸ¨D, E, hDEâŸ©,
  --   simp,
  --   change âˆƒ (C : â„¤), âˆ€ (p : â„¤), abs (-(f.1 (g.1 p)) + g.1 (f.1 p)) < C,
  --   have h1 : âˆ€ p (H : abs E < abs p), abs (f.val (g.val p) - g.val (f.val p)) < D + 1,
  --     intros p hp,
  --     specialize hDE p,
  --     have hDE' : abs p * abs (f.val (g.val p) - g.val (f.val p)) < D * abs p + abs E,
  --       linarith [le_abs_self E],
  --     have : abs p * abs (f.val (g.val p) - g.val (f.val p)) < abs p * (D + 1),
  --       linarith,
  --     have habsp : abs p > 0, 
  --       linarith [abs_nonneg E],
  --     have hiff := @mul_lt_mul_left â„¤ (linear_ordered_ring.to_linear_ordered_semiring) (abs (f.val (g.val p) - g.val (f.val p)))
  --       (D + 1) (abs p) habsp,
  --     rw â† hiff,
  --     exact this,
  --   have hB : âˆƒ B, âˆ€ (p : â„¤), abs p â‰¤ abs E â†’ abs (f.val (g.val p) - g.val (f.val p)) < B,
  --     have hfin : set.finite ((Î» p, abs (f.val (g.val p) - g.val (f.val p))) '' (set.Icc (-(abs E)) (abs E))),
  --       apply set.finite.image,
  --       exact âŸ¨fintype.of_finset (finset.Ico_â„¤ (-(abs E)) (abs E + 1)) (by {simp [int.lt_add_one_iff]})âŸ©,
  --     have hbdd : bdd_above ((Î» p, abs (f.val (g.val p) - g.val (f.val p))) '' (set.Icc (-(abs E)) (abs E))),
  --       apply set.finite.bdd_above hfin,
  --     cases hbdd with m hm,
  --     simp at hm,
  --     use m + 1,
  --     intros p hpE,
  --     rw abs_le at hpE,
  --     specialize @hm (abs (f.val (g.val p) - g.val (f.val p))) p hpE.1 hpE.2 rfl,
  --     linarith,
  --   cases hB with B hB,
  --   use max B (D + 1),
  --   intro p,
  --   rw â† abs_neg,
  --   have : -(-f.val (g.val p) + g.val (f.val p)) = f.val (g.val p) - g.val (f.val p),
  --     ring,
  --   rw this,
  --   have hpE := le_or_lt (abs p) (abs E),
  --   cases hpE,
  --     specialize hB p hpE,
  --     linarith [le_max_left B (D + 1)],
  --   specialize h1 p hpE,
  --   linarith [le_max_right B (D + 1)],
  -- end

  -- lemma ğ”¼.mul_comm : âˆ€ (a b : ğ”¼), ğ”¼.mul a b = ğ”¼.mul b a :=
  -- begin
  --   intros a b,
  --   cases lemma12 a with u hu,
  --   cases lemma12 b with v hv,
  --   rw [â† hu, â† hv, lemma17 u v, lemma17 v u, quotient_add_group.eq],
  --   apply lemma25,
  -- end

  -- lemma ğ”¼.mul_right_distrib : âˆ€ (a b c : ğ”¼), ğ”¼.mul (a + b) c = ğ”¼.mul a c + ğ”¼.mul b c :=
  -- begin
  --   intros a b c,
  --   cases lemma12 a with u hu,
  --   cases lemma12 b with v hv,
  --   cases lemma12 c with w hw,
  --   have H1 := lemma17 (u + v) w,
  --   have H2 := lemma17 u w,
  --   have H3 := lemma17 v w,
  --   have heq : âˆ€ v w, (@coe â†¥S ğ”¼) eudoxus_reals_group.has_lift_t (v + w) = 
  --     @has_add.add ğ”¼ (@add_semigroup.to_has_add ğ”¼ (add_monoid.to_add_semigroup ğ”¼)) â†‘v â†‘w := Î» v w, rfl,
  --   rw heq at H1,
  --   rw [â† hu, â† hv, â† hw],
  --     rw [H1, H2, H3, â† heq, quotient_add_group.eq],
  --     apply lemma18,
  --     simp,
  -- end

  -- noncomputable instance comm_ring_ğ”¼ : comm_ring ğ”¼ := {
  --   mul := ğ”¼.mul,
  --   mul_assoc := begin
  --     intros a b c,
  --     cases lemma12 a with u hu,
  --     cases lemma12 b with v hv,
  --     cases lemma12 c with w hw,
  --     set ab : â†¥S := âŸ¨u.1 âˆ˜ v.1, lemma14 u vâŸ© with hab, 
  --     set abc : â†¥S := âŸ¨ab.1 âˆ˜ w.1, lemma14 ab wâŸ© with habc,
  --     set bc : â†¥S := âŸ¨v.1 âˆ˜ w.1, lemma14 v wâŸ© with hbc,
  --     set abc' : â†¥S := âŸ¨u.1 âˆ˜ bc.1, lemma14 u bcâŸ© with habc',  
  --     have H1 := lemma17 u v,
  --     have H2 := lemma17 ab w,
  --     have H3 := lemma17 v w,
  --     have H4 := lemma17 u bc,
  --     rw [hu, hv] at H1,
  --     rw [hab, â† habc, â† H1, hw] at H2,
  --     rw [hv, hw] at H3,
  --     rw [hbc, â† habc', â† H3, hu] at H4,
  --     show ğ”¼.mul (ğ”¼.mul a b) c = ğ”¼.mul a (ğ”¼.mul b c),
  --     rw [H2, H4],
  --   end,
  --   one := â†‘(âŸ¨(id : â„¤ â†’ â„¤), lemma16âŸ© : S),
  --   one_mul := begin
  --     intro a,
  --     cases lemma12 a with u hu,
  --     rw â† hu,
  --     change ğ”¼.mul â†‘(âŸ¨(id : â„¤ â†’ â„¤), lemma16âŸ© : S) (â†‘u : ğ”¼) = â†‘u,
  --     simp,
  --     rw quotient_add_group.eq,
  --     have h1 := classical.some_spec (lemma12 â†‘u),
  --     have h2 := classical.some_spec (lemma12 â†‘(âŸ¨(id : â„¤ â†’ â„¤), lemma16âŸ© : S)),
  --     have h3 := lemma15 h2 h1,
  --     have h4 : u = (âŸ¨(âŸ¨(id : â„¤ â†’ â„¤), lemma16âŸ© : S).val âˆ˜ u.val, lemma14 âŸ¨(id : â„¤ â†’ â„¤), lemma16âŸ© uâŸ© : S),
  --       simp,
  --     rw h4,
  --     convert h3,
  --     simp,
  --   end,
  --   mul_one := begin
  --     intro a,
  --     cases lemma12 a with u hu,
  --     rw â† hu,
  --     change ğ”¼.mul (â†‘u : ğ”¼) â†‘(âŸ¨(id : â„¤ â†’ â„¤), lemma16âŸ© : S) = â†‘u,
  --     simp,
  --     rw quotient_add_group.eq,
  --     have h1 := classical.some_spec (lemma12 â†‘u),
  --     have h2 := classical.some_spec (lemma12 â†‘(âŸ¨(id : â„¤ â†’ â„¤), lemma16âŸ© : S)),
  --     have h3 := lemma15 h1 h2,
  --     have h4 : u = (âŸ¨(âŸ¨(id : â„¤ â†’ â„¤), lemma16âŸ© : S).val âˆ˜ u.val, lemma14 âŸ¨(id : â„¤ â†’ â„¤), lemma16âŸ© uâŸ© : S),
  --       simp,
  --     rw h4,
  --     convert h3,
  --     simp,
  --   end,
  --   left_distrib := begin
  --     intros a b c,
  --     change ğ”¼.mul a (b + c) = ğ”¼.mul a b + ğ”¼.mul a c,
  --     rw [ğ”¼.mul_comm],
  --     have := ğ”¼.mul_comm a c,
  --     symmetry,
  --     rw [ğ”¼.mul_comm, this],
  --     symmetry,
  --     apply ğ”¼.mul_right_distrib,
  --   end,
  --   right_distrib := begin
  --     intros a b c,
  --     change ğ”¼.mul (a + b) c = ğ”¼.mul a c + ğ”¼.mul b c,
  --     apply ğ”¼.mul_right_distrib,
  --   end, 
  --   mul_comm := begin
  --     intros a b,
  --     apply ğ”¼.mul_comm,
  --   end,
  --   ..add_comm_group_ğ”¼ }

  -- @[simp] lemma ğ”¼.mul_eq' (a b : ğ”¼) : a * b = ğ”¼.mul a b := rfl

  -- @[simp] lemma ğ”¼.one_eq' : (1 : ğ”¼) = â†‘(âŸ¨(id : â„¤ â†’ â„¤), lemma16âŸ© : S) := rfl

  -- lemma lemma26 {f : â„¤ â†’ â„¤} : (âˆ€ p < 0, f p = -(f (-p))) â†’ (âˆƒ C, âˆ€ m n (hm : 0 â‰¤ m) (hn : 0 â‰¤ n),
  --   abs (df f m n) < C) â†’ f âˆˆ S :=
  -- begin
  --   rintro h1 âŸ¨C, h2âŸ©,
  --   use C,
  --   intros p q,
  --   have hp := le_or_lt 0 p,
  --   have hq := le_or_lt 0 q,
  --   cases hp,
  --   { cases hq,
  --       exact h2 p q hp hq,
  --     have hpq := le_or_lt 0 (p + q),
  --     cases hpq,
  --       have h0q : 0 â‰¤ -q,
  --         linarith,
  --       simp,
  --       specialize h2 (p + q) (-q) hpq h0q,
  --       simp at h2,
  --       have : -(f (p + q) - f p - -f (-q)) = f p - f (p + q) - f (-q),
  --         ring,
  --       rw [h1 q hq, â† abs_neg, this],
  --       exact h2, 
  --     have hpq' : 0 â‰¤ -(p + q),
  --       linarith,
  --     specialize h2 (-(p + q)) p hpq' hp,
  --     simp at h2,
  --     simp,
  --     have : -f (-(p + q)) - f p - -f (-q) = f (-q) - f (-q + -p) - f p,
  --       have : -(p + q) = -q + -p,
  --         ring,
  --       rw this,
  --       ring,
  --     rw [h1 q hq, h1 (p + q) hpq, this],
  --     exact h2, },
  --   cases hq,
  --   { have hpq := le_or_lt 0 (p + q),
  --     cases hpq,
  --       have h0p : 0 â‰¤ -p,
  --         linarith,
  --       simp,
  --       specialize h2 (p + q) (-p) hpq h0p,
  --       simp at h2,
  --       have : -(f (p + q) - -f (-p) - f q) = f (p + q + -p) - f (p + q) - f (-p),
  --         have : p + q + -p = q,
  --           ring,
  --         rw this,
  --         ring,
  --       rw [h1 p hp, â† abs_neg, this],
  --       simp [h2], 
  --     have hpq' : 0 â‰¤ -(p + q),
  --       linarith,
  --     specialize h2 (-(p + q)) q hpq' hq,
  --     simp at h2,
  --     simp,
  --     have : -f (-(p + q)) - -f (-p) - f q = f (-q + -p + q) - f (-q + -p) - f q,
  --       have eq1 : -(p + q) = -q + -p,
  --         ring,
  --       have eq2 : -q + -p + q = -p,
  --         ring,
  --       rw [eq1, eq2],
  --       ring,
  --     rw [h1 p hp, h1 (p + q) hpq, this],
  --     simp [h2], },
  --   have H1 : df f p q = -(df f (-p) (-q)),
  --     have hpq : p + q < 0,
  --       linarith,
  --     have heq : -(p + q) = -p - q,
  --       ring,
  --     simp,
  --     rw [h1 p hp, h1 q hq, h1 (p + q) hpq],
  --     ring,
  --     rw heq,
  --     ring,
  --   have h0p : 0 â‰¤ -p,
  --     linarith,
  --   have h0q : 0 â‰¤ -q,
  --     linarith,
  --   specialize h2 (-p) (-q) h0p h0q,
  --   rw [H1, abs_neg],
  --   exact h2,
  -- end

  -- lemma lemma27 (S : set â„¤) : S.nonempty â†’ (âˆ€ n : â„¤, n âˆˆ S â†’ 0 â‰¤ n) â†’ âˆƒ n âˆˆ S, âˆ€ m âˆˆ S, n â‰¤ m := 
  -- begin
  --   intros H1 H2,
  --   set S' := {a : â„• | âˆƒ (s : â„¤) (Hs : s âˆˆ S), s = â†‘a},
  --   have hS' : S'.nonempty,
  --     show âˆƒ (t : â„•) (s : â„¤) (Hs : s âˆˆ S), s = â†‘t,
  --     cases H1 with x hx,
  --     specialize H2 x hx,
  --     have := int.eq_coe_of_zero_le H2,
  --     cases this,
  --     use [this_w, x, hx, this_h],
  --   have hS'S : âˆ€ {a : â„•}, a âˆˆ S' â†’ â†‘a âˆˆ S,
  --     rintro a âŸ¨a', ha', haa'âŸ©,
  --     rw â† haa',
  --     exact ha',
  --   use â†‘(nat.find_x hS').1,
  --   cases (nat.find_x hS').2 with h1 h2,
  --   use hS'S h1,
  --   intros m hm,
  --   specialize H2 m hm,
  --   cases int.eq_coe_of_zero_le H2 with m' hm',
  --   specialize h2 m',
  --   have h2' : m' âˆˆ S' â†’ (nat.find_x hS').val â‰¤ m',
  --     contrapose,
  --     simp only [exists_prop, not_le, exists_eq_right],
  --     exact h2,
  --   have : m' âˆˆ S' := âŸ¨m, hm, hm'âŸ©,
  --   specialize h2' this,
  --   rw hm',
  --   exact int.coe_nat_le.mpr h2',
  -- end

  -- def P' := {f : S | âˆ€ n (hn : 0 < n), âˆƒ p (hp : 0 < p), n < f.1 p}

  -- @[simp] lemma in_P'_iff (f : S) : f âˆˆ P' â†” âˆ€ n (hn : 0 < n), âˆƒ p (hp : 0 < p), n < f.1 p := iff.rfl

  -- lemma lemma28 (f : P') : âˆ€ p (hp : 0 â‰¤ p), âˆƒ n (hn : n âˆˆ {m | p â‰¤ f.1.1 m âˆ§ 0 â‰¤ m}), âˆ€ x âˆˆ {m | p â‰¤ f.1.1 m âˆ§ 0 â‰¤ m}, n â‰¤ x :=
  -- begin
  --   intros p hp,
  --   cases f with f hf,
  --   rw in_P'_iff at hf,
  --   rw lemma8 f at hf,
  --   have hp1 : 0 < p + 1,
  --     linarith,
  --   specialize hf (p + 1) hp1,
  --   have hnonempty : {m : â„¤ | p â‰¤ f.val m âˆ§ 0 â‰¤ m}.nonempty,
  --     cases hf with N hf,
  --     have hN : N < max 0 (N + 1),
  --       rw lt_max_iff,
  --         right,
  --       linarith,
  --     specialize hf (max 0 (N + 1)) hN,   
  --     use (max 0 (N + 1)),
  --     simp only [set.mem_set_of_eq],
  --     split, 
  --       linarith,
  --     rw le_max_iff,
  --     left,
  --     linarith,
  --   have hall : âˆ€ n : â„¤, n âˆˆ {m : â„¤ | p â‰¤ f.val m âˆ§ 0 â‰¤ m} â†’ 0 â‰¤ n,
  --     intros n hn,
  --     exact hn.2,
  --   exact lemma27 {m : â„¤ | p â‰¤ f.val m âˆ§ 0 â‰¤ m} hnonempty hall,
  -- end

  -- lemma lemma29 (a : ğ”¼) : a âˆˆ P âˆ¨ a = 0 âˆ¨ -a âˆˆ P :=
  -- begin
  --   cases lemma12 a with u hu,
  --   cases lemma5 u,
  --     left,
  --     use [u.1, u.2],
  --     simp only [subtype.coe_eta, subtype.val_eq_coe],
  --     use [hu, h],
  --   cases h,
  --     right,
  --     right,
  --     have : â†‘-u = -a,
  --       rw â† hu,
  --       refl,
  --     use [-u, this],
  --     intros n hn,
  --     have hn0 : -n < 0,
  --       linarith,
  --     specialize h (-n) hn0,
  --     rcases h with âŸ¨p, hp, hâŸ©,
  --     use [p, hp],
  --     have huval : (-u).val p = -(u.val p) := rfl,
  --     linarith,
  --   right,
  --   left,
  --   have : (0 : ğ”¼) = â†‘(0 : S) := rfl,
  --   symmetry,
  --   rw [â† hu, this, quotient_add_group.eq],
  --   simp,
  --   exact lemma4 u h,
  -- end

  -- lemma lemma30 {a : ğ”¼} : a âˆ‰ P â†’ Â¬(a = 0) â†’ -a âˆˆ P :=
  -- begin
  --   intros h1 h2,
  --   cases lemma29 a,
  --     exfalso,
  --     exact h1 h,
  --   cases h,
  --     exfalso,
  --     exact h2 h,
  --   exact h,
  -- end

  -- noncomputable def ğ”¼.inv.g1 : P' â†’ (â„¤ â†’ â„¤) := Î» f, (Î» p,
  -- if hp : 0 â‰¤ p then begin
  --   choose n hn using lemma28 f p hp,
  --   exact n,
  -- end
  -- else begin
  --   have hp' : 0 â‰¤ -p,
  --     linarith,
  --   choose n hn using lemma28 f (-p) hp',
  --   exact -n,
  -- end)

  -- lemma lemma31 (f : P') :  âˆ€ n (hn : 0 â‰¤ n), 0 â‰¤ ğ”¼.inv.g1 f n :=
  -- begin
  --   intros n hn,
  --   simp only [ğ”¼.inv.g1],
  --   split_ifs,
  --   have := classical.some_spec (lemma28 f n hn),
  --   cases this with hsome1 hsome2,
  --   rw set.mem_set_of_eq at hsome1,
  --   exact hsome1.2,
  -- end

  -- lemma lemma32 (f : P') :  âˆƒ n (hn : 0 < n), 0 < ğ”¼.inv.g1 f n :=
  -- begin
  --   by_contradiction hfalse,
  --   have hfalse' : âˆ€ n (hn : 0 < n), ğ”¼.inv.g1 f n â‰¤ 0,
  --     rw not_exists at hfalse,
  --     intros n hn,
  --     specialize hfalse n,
  --     rw not_exists at hfalse,
  --     specialize hfalse hn,
  --     linarith,
  --   clear hfalse,
  --   cases f with f hf,
  --   rw in_P'_iff at hf,
  --   have hfalse1 :  âˆ€ (n : â„¤), 0 < n â†’ ğ”¼.inv.g1 âŸ¨f, hfâŸ© n = 0,
  --     intros n hn0,
  --     specialize hfalse' n hn0,
  --     have hn0' : 0 â‰¤ n,
  --       linarith,
  --     have := lemma31 âŸ¨f, hfâŸ© n hn0',
  --     exact le_antisymm hfalse' this,
  --   have hfalse2 : âˆ€ (n : â„¤), 0 < n â†’ n â‰¤ f.1 0,
  --     intros n hn,
  --     specialize hfalse1 n hn,
  --     simp only [ğ”¼.inv.g1] at hfalse1, 
  --     split_ifs at hfalse1,
  --       have hn' : 0 â‰¤ n,
  --         linarith,
  --       have := classical.some_spec (lemma28 âŸ¨f, hfâŸ© n hn'),
  --       cases this with hsome1 hsome2,
  --       simp at hsome1,
  --       rw â† hfalse1,
  --       simp,
  --       exact hsome1.1,
  --     exfalso,
  --     linarith,
  --   have hlt : 0 < max (f.val 0 + 1) 1,
  --     rw lt_max_iff,
  --       right,
  --     norm_num,
  --   specialize hfalse2 (max (f.val 0 + 1) 1) hlt,
  --   have : (f.val 0 + 1) â‰¤ max (f.val 0 + 1) 1 := le_max_left (f.val 0 + 1) 1,
  --   linarith,
  -- end

  -- lemma lemma33 (f : P') : âˆ€ n m (hn : 0 â‰¤ n) (hm : n â‰¤ m), ğ”¼.inv.g1 f n â‰¤ ğ”¼.inv.g1 f m :=
  -- begin
  --   intros n m hn hm,
  --   simp only [ğ”¼.inv.g1],
  --   have hm' : 0 â‰¤ m,
  --     linarith,
  --   split_ifs,
  --   have h1 := classical.some_spec (lemma28 f n hn),
  --   have h2 := classical.some_spec (lemma28 f m hm'),
  --   set gn := classical.some (lemma28 f n hn) with hgn,
  --   set gm := classical.some (lemma28 f m hm') with hgm,
  --   rw â† hgn at *,
  --   rw â† hgm at *,
  --   cases h1 with h11 h12,
  --   cases h2 with h21 h22,
  --   rw set.mem_set_of_eq at *,
  --   have : n â‰¤ f.val.val gm,
  --     linarith,
  --   specialize h12 gm,
  --   rw set.mem_set_of_eq at h12,
  --   specialize h12 âŸ¨this, h21.2âŸ©,
  --   exact h12,
  -- end

  -- lemma lemma34 (f : P') :  âˆƒ N (HN : 0 < N), âˆ€ n (hn : N â‰¤ n), 0 < ğ”¼.inv.g1 f n :=
  -- begin
  --   rcases lemma32 f with âŸ¨N, hN, hâŸ©,
  --   have : 0 â‰¤ N,
  --     linarith,
  --   use [N, hN],
  --   intros n hNn,
  --   have := lemma33 f N n this hNn,
  --   linarith,
  -- end

  -- lemma lemma35 (f : P') :  âˆ€ n (hn : 0 â‰¤ n), n â‰¤ f.1.1 (ğ”¼.inv.g1 f n) :=
  -- begin
  --   intros n h0n,
  --   simp only [ğ”¼.inv.g1],
  --   split_ifs,
  --   have := classical.some_spec (lemma28 f n h0n),
  --   set gn := classical.some (lemma28 f n h0n) with hgn,
  --   rw â† hgn at *,
  --   cases this with hgn1 hgn2,
  --   rw set.mem_set_of_eq at hgn1,
  --   exact hgn1.1,
  -- end

  -- lemma lemma36 (f g h : â„¤ â†’ â„¤ â†’ â„¤) {c : â„¤} {F : P'} : (âˆ€ a b (ha : c â‰¤ a) (hb : 0 â‰¤ b) (hgb : 0 < ğ”¼.inv.g1 F b), f a b > 0 âˆ§ g a b < 0) â†’ (âˆƒ C, âˆ€ a b, abs (h a b - f a b) < C) â†’ 
  --   (âˆƒ D, âˆ€ a b, abs (h a b - g a b) < D) â†’ (âˆƒ E, âˆ€ a b (ha : c â‰¤ a) (hb : 0 â‰¤ b) (hgb : 0 < ğ”¼.inv.g1 F b), abs (h a b) < E) :=
  -- begin
  --   rintro h âŸ¨C, h1âŸ© âŸ¨D, h2âŸ©,
  --   use C + D,
  --   intros a b ha hb hgb,
  --   specialize h a b ha hb hgb,
  --   specialize h1 a b,
  --   specialize h2 a b,
  --   cases h with hf hg,
  --   rw abs_lt at *,
  --   cases h1,
  --   cases h2,
  --   split,
  --     linarith,
  --   linarith,
  -- end

  -- lemma lemma37 (f : P') (T : set â„¤) : (âˆƒ C, âˆ€ x âˆˆ T, abs (f.1.1 x) < C) â†’ (âˆƒ B, âˆ€ x âˆˆ T, abs x â‰¤ B) :=
  -- begin
  --   rintro âŸ¨C, hCâŸ©,
  --   by_contradiction hfalse,
  --   have hfalse' : âˆ€ (B : â„¤), âˆƒ (x : â„¤), x âˆˆ T âˆ§ B < abs x,
  --     rw not_exists at hfalse,
  --     intro B,
  --     specialize hfalse B,
  --     rw not_forall at hfalse,
  --     cases hfalse with x hx,
  --     use x,
  --     rw not_imp at hx,
  --     use hx.1,
  --     have := hx.2,
  --     simp at this,
  --     exact this,
  --   clear hfalse,
  --   cases f with f hf,
  --   rw in_P'_iff at hf,
  --   have := lemma2 f hf,
  --   have hD : âˆƒ D, âˆ€ p, abs (f.1 p + f.1 (-p)) < D,
  --     rcases f with âŸ¨f, E, hEâŸ©,
  --     use E + abs (f 0),
  --     intro p,
  --     specialize hE p (-p),
  --     rw â† abs_neg at hE,
  --     simp at hE,
  --     simp,
  --     have heq : f p + f (-p) = (f (-p) - (f 0 - f p)) + f 0,
  --       ring,
  --     rw heq,
  --     linarith [abs_add (f (-p) - (f 0 - f p)) (f 0), le_abs_self (f 0)],
  --   cases hD with D hD,
  --   have h0D : 0 < D,
  --     linarith [hD 0, abs_nonneg (f.1 0 + f.1 (-0))],
  --   have hCD : 0 < max 0 C + D,
  --     linarith [le_max_left 0 C],
  --   specialize this (max 0 C + D) hCD,
  --   cases this with N hN,
  --   rcases hfalse' N with âŸ¨x, hxT, hNxâŸ©,
  --   rw lt_abs at hNx,
  --   cases hNx,
  --     specialize hC x hxT,
  --     specialize hN x hNx,
  --     simp at hC,
  --     simp at hN,
  --     linarith [le_abs_self ((â†‘f : (â„¤ â†’ â„¤)) x), le_max_left 0 C, le_max_right 0 C],
  --   specialize hC x hxT,
  --   specialize hN (-x) hNx,
  --   specialize hD x,
  --   simp at hC,
  --   simp at hN,
  --   have : abs ((â†‘f : â„¤ â†’ â„¤) (-x)) < C + D,
  --     rw â† abs_neg at hC,
  --     simp at hD,
  --     have : (â†‘f : â„¤ â†’ â„¤) (-x) = -(â†‘f : â„¤ â†’ â„¤) x + ((â†‘f : â„¤ â†’ â„¤) x + (â†‘f : â„¤ â†’ â„¤) (-x)),
  --       ring,
  --     rw this,
  --     linarith [abs_add (-(â†‘f : â„¤ â†’ â„¤) x) ((â†‘f : â„¤ â†’ â„¤) x + (â†‘f : â„¤ â†’ â„¤) (-x))],
  --   linarith [le_abs_self ((â†‘f : (â„¤ â†’ â„¤)) (-x)), le_max_right 0 C],
  -- end

  -- lemma lemma38 (f : P') : âˆƒ C, âˆ€ m n, abs ((f.1.1 (ğ”¼.inv.g1 f (m + n)) - f.1.1 (ğ”¼.inv.g1 f m) - f.1.1 (ğ”¼.inv.g1 f n)) - 
  --   (f.1.1 (ğ”¼.inv.g1 f (m + n)) - f.1.1 (ğ”¼.inv.g1 f m - 1) - f.1.1 (ğ”¼.inv.g1 f n - 1))) < C :=
  -- begin
  --   rcases f with âŸ¨âŸ¨f, C, hCâŸ©, hfâŸ©,
  --   use 2 * C + 2 * abs (f 1),
  --   intros m n,
  --   simp,
  --   ring,
  --   have hC' := hC,
  --   specialize hC (ğ”¼.inv.g1 âŸ¨âŸ¨f, _âŸ©, hfâŸ© m - 1) 1,
  --   specialize hC' (ğ”¼.inv.g1 âŸ¨âŸ¨f, _âŸ©, hfâŸ© n - 1) 1,
  --   simp at hC,
  --   simp at hC',
  --   rw abs_lt at *,
  --   cases hC,
  --   cases hC',
  --   split,
  --     linarith [le_abs_self (f 1)],
  --   linarith [le_abs_self (-f 1), abs_neg (f 1)],
  -- end

  -- lemma lemma39 (f : P') : âˆƒ C, âˆ€ m n, abs ((f.1.1 (ğ”¼.inv.g1 f (m + n)) - f.1.1 (ğ”¼.inv.g1 f m) - f.1.1 (ğ”¼.inv.g1 f n)) - 
  --   (f.1.1 (ğ”¼.inv.g1 f (m + n) - 1) - f.1.1 (ğ”¼.inv.g1 f m) - f.1.1 (ğ”¼.inv.g1 f n))) < C :=
  -- begin
  --   rcases f with âŸ¨âŸ¨f, C, hCâŸ©, hfâŸ©,
  --   use C + abs (f 1),
  --   intros m n,
  --   simp,
  --   ring,
  --   specialize hC (ğ”¼.inv.g1 âŸ¨âŸ¨f, _âŸ©, hfâŸ© (m + n) - 1) 1,
  --   simp at hC,
  --   rw abs_lt at *,
  --   cases hC,
  --   split,
  --     linarith [le_abs_self (-f 1), abs_neg (f 1)],
  --   linarith [le_abs_self (f 1)],
  -- end

  -- lemma lemma40 (f : P') : âˆƒ C, âˆ€ m n, abs (f.1.1 (ğ”¼.inv.g1 f (m + n) - (ğ”¼.inv.g1 f m) - (ğ”¼.inv.g1 f n)) - 
  --   (f.1.1 (ğ”¼.inv.g1 f (m + n)) - f.1.1 (ğ”¼.inv.g1 f m) - f.1.1 (ğ”¼.inv.g1 f n))) < C :=
  -- begin
  --   rcases f with âŸ¨âŸ¨f, C, hCâŸ©, hfâŸ©,
  --   use 2 * C,
  --   intros m n,
  --   have : âˆ€ p q r, abs (f(r - p - q) - (f r - f p - f q)) < 2 * C,
  --     intros p q r,
  --     have hC' := hC,
  --     specialize hC (r - p - q) (p + q),
  --     specialize hC' p q,
  --     simp at hC,
  --     simp at hC',
  --     rw abs_lt at *,
  --     cases hC,
  --     cases hC',
  --     split,
  --       linarith,
  --     linarith,
  --   exact this (ğ”¼.inv.g1 âŸ¨âŸ¨f, _âŸ©, hfâŸ© m) (ğ”¼.inv.g1 âŸ¨âŸ¨f, _âŸ©, hfâŸ© n) (ğ”¼.inv.g1 âŸ¨âŸ¨f, _âŸ©, hfâŸ© (m + n)),
  -- end

  -- lemma lemma41 (f : P') : âˆƒ C, âˆ€ m n, abs (f.1.1 (ğ”¼.inv.g1 f (m + n) - (ğ”¼.inv.g1 f m) - (ğ”¼.inv.g1 f n)) - 
  --   (f.1.1 (ğ”¼.inv.g1 f (m + n)) - f.1.1 (ğ”¼.inv.g1 f m - 1) - f.1.1 (ğ”¼.inv.g1 f n - 1))) < C :=
  -- begin
  --   cases lemma38 f with C1 hC1,
  --   cases lemma40 f with C2 hC2,
  --   use C1 + C2,
  --   intros m n,
  --   specialize hC1 m n,
  --   specialize hC2 m n,
  --   rw abs_lt at *,
  --   split,
  --     linarith,
  --   linarith,
  -- end

  -- lemma lemma42 (f : P') : âˆƒ C, âˆ€ m n, abs (f.1.1 (ğ”¼.inv.g1 f (m + n) - (ğ”¼.inv.g1 f m) - (ğ”¼.inv.g1 f n)) - 
  --   (f.1.1 (ğ”¼.inv.g1 f (m + n) - 1) - f.1.1 (ğ”¼.inv.g1 f m) - f.1.1 (ğ”¼.inv.g1 f n))) < C :=
  -- begin
  --   cases lemma39 f with C1 hC1,
  --   cases lemma40 f with C2 hC2,
  --   use C1 + C2,
  --   intros m n,
  --   specialize hC1 m n,
  --   specialize hC2 m n,
  --   rw abs_lt at *,
  --   split,
  --     linarith,
  --   linarith,
  -- end

  -- lemma lemma43 (f : P') :  âˆ€ n (hn : 0 â‰¤ n), 0 < ğ”¼.inv.g1 f n â†’ (f.1.1 (ğ”¼.inv.g1 f n - 1) < n âˆ§ n â‰¤ f.1.1 (ğ”¼.inv.g1 f n)) :=
  -- begin
  --   intros n h0n h,
  --   simp only [ğ”¼.inv.g1],
  --   split,
  --   { split_ifs,
  --     have := classical.some_spec (lemma28 f n h0n),
  --     set gn := classical.some (lemma28 f n h0n) with hgn,
  --     rw â† hgn at *,
  --     cases this with hgn1 hgn2,
  --     by_contradiction hfgn,
  --     rw not_lt at hfgn,
  --     specialize hgn2 (gn - 1),
  --     have : gn - 1 âˆˆ {m : â„¤ | n â‰¤ f.val.val m âˆ§ 0 â‰¤ m},
  --       rw set.mem_set_of_eq,
  --       use hfgn,
  --       simp only [ğ”¼.inv.g1] at h,
  --       split_ifs at h,
  --       rw â† hgn at *,
  --       linarith,
  --     specialize hgn2 this,
  --     linarith, },
  --   { exact lemma35 f n h0n, },
  -- end

  -- lemma lemma44 (f : P') : âˆƒ C, âˆ€ m n (hgn : 0 = ğ”¼.inv.g1 f n), abs ((f.1.1 (ğ”¼.inv.g1 f (m + n) - (ğ”¼.inv.g1 f m) - (ğ”¼.inv.g1 f n))) - 
  --   (f.1.1 (ğ”¼.inv.g1 f (m + n)) - f.1.1 (ğ”¼.inv.g1 f m - 1))) < C :=
  -- begin
  --   rcases f with âŸ¨âŸ¨f, C, hCâŸ©, hfâŸ©,
  --   use 2 * C + abs (f 1),
  --   intros m n hgn,
  --   rw â†hgn,
  --   simp only [sub_zero, neg_add_rev, zero_add, set.mem_set_of_eq, add_neg_le_iff_le_add', neg_zero],
  --   have : âˆ€ p q, abs (f (p - q) - (f p - f (q - 1))) < 2 * C + abs (f 1),
  --     intros p q,
  --     have hC' := hC,
  --     specialize hC 1 (q - 1),
  --     specialize hC' (p - q) q,
  --     simp at hC,
  --     simp at hC',
  --     rw abs_lt at *,
  --     cases hC,
  --     cases hC',
  --     split,
  --       linarith [le_abs_self (f 1)],
  --     linarith [le_abs_self (-f 1), abs_neg (f 1)],
  --   specialize this (ğ”¼.inv.g1 âŸ¨âŸ¨f, _âŸ©, hfâŸ© (m + n)) (ğ”¼.inv.g1 âŸ¨âŸ¨f, _âŸ©, hfâŸ© (m)),
  --   exact this,
  -- end

  -- lemma lemma45 (f g h : â„¤ â†’ â„¤ â†’ â„¤) {c : â„¤} {F : P'} : (âˆ€ a b (ha : c â‰¤ a) (hb : 0 â‰¤ b) (hgb : 0 = ğ”¼.inv.g1 F b), f a b > 0 âˆ§ g a b < 0) â†’ (âˆƒ C, âˆ€ a b (hgb : 0 = ğ”¼.inv.g1 F b),
  --   abs (h a b - f a b) < C) â†’ (âˆƒ D, âˆ€ a b, abs (h a b - g a b) < D) â†’ (âˆƒ E, âˆ€ a b (ha : c â‰¤ a) (hb : 0 â‰¤ b) (hgb : 0 = ğ”¼.inv.g1 F b), abs (h a b) < E) :=
  -- begin
  --   rintro h âŸ¨C, h1âŸ© âŸ¨D, h2âŸ©,
  --   use C + D,
  --   intros a b ha hb hgb,
  --   specialize h a b ha hb hgb,
  --   specialize h1 a b hgb,
  --   specialize h2 a b,
  --   cases h with hf hg,
  --   rw abs_lt at *,
  --   cases h1,
  --   cases h2,
  --   split,
  --     linarith,
  --   linarith,
  -- end

  -- lemma lemma46 (f : P') : âˆƒ (N : â„¤) (C : â„¤) , âˆ€ (m n : â„¤), N â‰¤ m â†’ 0 â‰¤ n â†’ abs (df (Î» (p : â„¤), ğ”¼.inv.g1 f p) m n) < C :=
  -- begin
  --   rcases lemma34 f with âŸ¨N, hN, hfNâŸ©,
  --   have h1 : âˆ€ m n (hm : N â‰¤ m) (h0n : 0 â‰¤ n) (hgn : 0 < ğ”¼.inv.g1 f n), (f.1.1 (ğ”¼.inv.g1 f m - 1) < m âˆ§ m â‰¤ f.1.1 (ğ”¼.inv.g1 f m)) âˆ§ (f.1.1 (ğ”¼.inv.g1 f n - 1) < n âˆ§ 
  --     n â‰¤ f.1.1 (ğ”¼.inv.g1 f n)) âˆ§ (f.1.1 (ğ”¼.inv.g1 f (m + n) - 1) < m + n âˆ§ m + n â‰¤ f.1.1 (ğ”¼.inv.g1 f (m + n))),
  --     intros m n hm h0n hgn,
  --     have h0m : 0 â‰¤ m,
  --       linarith,
  --     have h0mn : 0 â‰¤ m + n,
  --       linarith,
  --     have hmn : N â‰¤ m + n,
  --       linarith,
  --     use [lemma43 f m h0m (hfN m hm), lemma43 f n h0n hgn, lemma43 f (m + n) h0mn (hfN (m + n) hmn)],
  --   set f1 : â„¤ â†’ â„¤ â†’ â„¤ := Î» m n, f.1.1 (ğ”¼.inv.g1 f (m + n)) - f.1.1 (ğ”¼.inv.g1 f m - 1) - f.1.1 (ğ”¼.inv.g1 f n - 1),
  --   set f2 : â„¤ â†’ â„¤ â†’ â„¤ := Î» m n, f.1.1 (ğ”¼.inv.g1 f (m + n) - 1) - f.1.1 (ğ”¼.inv.g1 f m) - f.1.1 (ğ”¼.inv.g1 f n),
  --   set f3 : â„¤ â†’ â„¤ â†’ â„¤ := Î» m n, f.1.1 (ğ”¼.inv.g1 f (m + n) - (ğ”¼.inv.g1 f m) - (ğ”¼.inv.g1 f n)),
  --   have h2 : âˆ€ m n (hm : N â‰¤ m) (h0n : 0 â‰¤ n) (hgn : 0 < ğ”¼.inv.g1 f n), f1 m n > 0 âˆ§ f2 m n < 0,
  --     intros m n hm h0n hgn,
  --     rcases h1 m n hm h0n hgn with âŸ¨âŸ¨hm1, hm2âŸ©, âŸ¨hn1, hn2âŸ©, âŸ¨hmn1, hmn2âŸ©âŸ©,
  --     simp only [sub_lt_zero, gt_iff_lt, sub_pos],
  --     split,
  --       linarith,
  --     linarith,
  --   have := lemma36 f1 f2 f3 h2 (lemma41 f) (lemma42 f),
  --   set T := {t | âˆƒ m n (hm : N â‰¤ m) (hn : 0 â‰¤ n) (hgn : 0 < ğ”¼.inv.g1 f n), (ğ”¼.inv.g1 f (m + n) - (ğ”¼.inv.g1 f m) - (ğ”¼.inv.g1 f n)) = t},
  --   have hCT : âˆƒ C, âˆ€ x âˆˆ T, abs (f.1.1 x) < C,
  --     cases this with E hE,
  --     use E,
  --     intros x hxT,
  --     rcases hxT with âŸ¨m, n, hm, hn, hgn, hâŸ©,
  --     specialize hE m n hm hn hgn,
  --     rw â† h,
  --     linarith,
  --   cases lemma37 f T hCT with C1 hC1,
  --   have h3 : âˆ€ m n (hm : N â‰¤ m) (h0n : 0 â‰¤ n) (hgn : 0 = ğ”¼.inv.g1 f n), (f.1.1 (ğ”¼.inv.g1 f m - 1) < m âˆ§ m â‰¤ f.1.1 (ğ”¼.inv.g1 f m)) âˆ§ 
  --     (n â‰¤ f.1.1 (ğ”¼.inv.g1 f n)) âˆ§ (f.1.1 (ğ”¼.inv.g1 f (m + n) - 1) < m + n âˆ§ m + n â‰¤ f.1.1 (ğ”¼.inv.g1 f (m + n))),
  --     intros m n hm h0n hgn,
  --     have h0m : 0 â‰¤ m,
  --       linarith,
  --     have h0mn : 0 â‰¤ m + n,
  --       linarith,
  --     have hmn : N â‰¤ m + n,
  --       linarith,
  --     use [lemma43 f m h0m (hfN m hm), lemma35 f n h0n, lemma43 f (m + n) h0mn (hfN (m + n) hmn)],
  --   set f1' : â„¤ â†’ â„¤ â†’ â„¤ := Î» m n, f.1.1 (ğ”¼.inv.g1 f (m + n)) - f.1.1 (ğ”¼.inv.g1 f m - 1),
  --   set f2' : â„¤ â†’ â„¤ â†’ â„¤ := Î» m n, f.1.1 (ğ”¼.inv.g1 f (m + n) - 1) - f.1.1 (ğ”¼.inv.g1 f m) - f.1.1 (ğ”¼.inv.g1 f n),
  --   set f3' : â„¤ â†’ â„¤ â†’ â„¤ := Î» m n, f.1.1 (ğ”¼.inv.g1 f (m + n) - (ğ”¼.inv.g1 f m) - (ğ”¼.inv.g1 f n)),
  --   have h4 : âˆ€ m n (hm : N â‰¤ m) (h0n : 0 â‰¤ n) (hgn : 0 = ğ”¼.inv.g1 f n), f1' m n > 0 âˆ§ f2' m n < 0,
  --     intros m n hm h0n hgn,
  --     rcases h3 m n hm h0n hgn with âŸ¨âŸ¨hm1, hm2âŸ©, hn1, âŸ¨hmn1, hmn2âŸ©âŸ©,
  --     simp only [sub_lt_zero, gt_iff_lt, sub_pos],
  --     split,
  --       linarith,
  --     linarith,
  --   have := lemma45 f1' f2' f3' h4 (lemma44 f) (lemma42 f),
  --   set T' := {t | âˆƒ m n (hm : N â‰¤ m) (hn : 0 â‰¤ n) (hgn : 0 = ğ”¼.inv.g1 f n), (ğ”¼.inv.g1 f (m + n) - (ğ”¼.inv.g1 f m) - (ğ”¼.inv.g1 f n)) = t},
  --   have hCT' : âˆƒ C, âˆ€ x âˆˆ T', abs (f.1.1 x) < C,
  --     cases this with E hE,
  --     use E,
  --     intros x hxT,
  --     rcases hxT with âŸ¨m, n, hm, hn, hgn, hâŸ©,
  --     specialize hE m n hm hn hgn,
  --     rw â† h,
  --     linarith,
  --   cases lemma37 f T hCT with C1 hC1,
  --   cases lemma37 f T' hCT' with C2 hC2,
  --   use [N, (max C1 C2) + 1],
  --   intros m n hm hn,
  --   by_cases hgn : 0 = ğ”¼.inv.g1 f n,
  --   { specialize hC2 (df (Î» (p : â„¤), ğ”¼.inv.g1 f p) m n),
  --     have : df (Î» (p : â„¤), ğ”¼.inv.g1 f p) m n âˆˆ T',
  --       simp,
  --       use [m, hm, n, hn, hgn],
  --     specialize hC2 this,
  --     linarith [le_max_right C1 C2], },
  --   { have hgn' : 0 < ğ”¼.inv.g1 f n,
  --       have := lemma31 f n hn,
  --       exact lt_of_le_of_ne this hgn,
  --     specialize hC1 (df (Î» (p : â„¤), ğ”¼.inv.g1 f p) m n),
  --     have : df (Î» (p : â„¤), ğ”¼.inv.g1 f p) m n âˆˆ T,
  --       simp,
  --       use [m, hm, n, hn, hgn'],
  --     specialize hC1 this,
  --     linarith [le_max_left C1 C2], },
  -- end

  -- lemma lemma47 (f : P') : âˆƒ (C : â„¤) , âˆ€ (m n : â„¤), 0 â‰¤ m â†’ 0 â‰¤ n â†’ abs (df (Î» (p : â„¤), ğ”¼.inv.g1 f p) m n) < C :=
  -- begin
  --   rcases lemma46 f with âŸ¨N, C, hfNâŸ©,
  --   have hfs1 : set.finite (set.image2 (Î» m n, abs (df (Î» (p : â„¤), ğ”¼.inv.g1 f p) m n)) {m | 0 â‰¤ m âˆ§ m < N} {n | 0 â‰¤ n âˆ§ n < N}),
  --     apply set.finite.image2,
  --       split,
  --       apply fintype.of_finset (finset.Ico_â„¤ 0 N),
  --       simp,
  --     split,
  --     apply fintype.of_finset (finset.Ico_â„¤ 0 N),
  --     simp,
  --   have hbdd : bdd_above (set.image2 (Î» m n, abs (df (Î» (p : â„¤), ğ”¼.inv.g1 f p) m n)) {m | 0 â‰¤ m âˆ§ m < N} {n | 0 â‰¤ n âˆ§ n < N}),
  --     apply set.finite.bdd_above hfs1,
  --   simp at hbdd,
  --   cases hbdd with C1 hC1,
  --   simp at hC1,
  --   use max C C1 + 1,
  --   intros m n hm hn,
  --   have hmN := lt_or_le m N,
  --   have hnN := lt_or_le n N,
  --   cases hmN,
  --   { cases hnN,
  --       specialize @hC1 (abs (ğ”¼.inv.g1 f (m + n) - ğ”¼.inv.g1 f m - ğ”¼.inv.g1 f n)) m hm hmN n hn hnN rfl,
  --       simp,
  --       linarith [le_max_right C C1],
  --     specialize hfN n m hnN hm,
  --     simp at hfN,
  --     simp,
  --     have : ğ”¼.inv.g1 f (m + n) - ğ”¼.inv.g1 f m - ğ”¼.inv.g1 f n = ğ”¼.inv.g1 f (n + m) - ğ”¼.inv.g1 f n - ğ”¼.inv.g1 f m,
  --       rw [add_comm],
  --       ring,
  --     rw this,
  --     linarith [le_max_left C C1], },
  --   { specialize hfN m n hmN hn,
  --     linarith [le_max_left C C1], },
  -- end

  -- noncomputable def ğ”¼.inv.g : P' â†’ S := Î» f, âŸ¨Î» p, ğ”¼.inv.g1 f p, 
  -- begin
  --   apply lemma26,
  --   { intros p hp,
  --     simp only [ğ”¼.inv.g1],
  --     split_ifs with hp1 hp2,
  --           exfalso,
  --           linarith,
  --         exfalso,
  --         linarith,
  --       refl,
  --     exfalso,
  --     linarith, },
  --   exact lemma47 f,
  -- endâŸ©

  -- lemma lemma48 (f : P') : âˆƒ (C : â„¤), âˆ€ n (hn : 0 â‰¤ n), abs (f.1.1 ((ğ”¼.inv.g f).1 n) - n) < C :=
  -- begin
  --   have H : âˆƒ (N C : â„¤), âˆ€ n (hn : N â‰¤ n), abs (f.1.1 ((ğ”¼.inv.g f).1 n) - n) < C,
  --     rcases lemma34 f with âŸ¨N, hN, hâŸ©,
  --     have hN' : 0 â‰¤ N,
  --       linarith,
  --     set g := ğ”¼.inv.g f with hg,
  --     choose C hC using f.1.2,
  --     use [N, C + abs (f.1.1 1)],
  --     intros n hn,
  --     specialize h n hn,
  --     have h0n : 0 â‰¤ n,
  --       linarith,
  --     have key := lemma43 f n h0n h,
  --     have : g.val = ğ”¼.inv.g1 f,
  --       rw hg,
  --       refl,
  --     rw â† this at *,
  --     specialize hC 1 (g.1 n - 1),
  --     simp only [add_sub_cancel'_right, df_eq] at hC,
  --     cases key,
  --     rw abs_lt at *,
  --     cases hC,
  --     split,
  --       linarith [abs_nonneg (f.1.1 1)],
  --     linarith [le_abs_self (f.1.1 1)],
  --   rcases H with âŸ¨N, C, HâŸ©,
  --     have hfin : set.finite ((Î» n, abs (f.1.1 ((ğ”¼.inv.g f).1 n) - n)) '' set.Ico 0 N),
  --     apply set.finite.image,
  --     split,
  --     apply fintype.of_finset (finset.Ico_â„¤ 0 N),
  --     simp,
  --   have hbdd : bdd_above ((Î» n, abs (f.1.1 ((ğ”¼.inv.g f).1 n) - n)) '' set.Ico 0 N),
  --     apply set.finite.bdd_above hfin,
  --   simp at hbdd,
  --   cases hbdd with C1 hC1,
  --   simp only [upper_bounds_eq, and_imp, set.mem_Ico, set.mem_image, set.mem_set_of_eq, exists_imp_distrib] at hC1,
  --   use max C C1 + 1,
  --   intros n hn,
  --   have hnN := lt_or_le n N,
  --   cases hnN,
  --     specialize @hC1 (abs (f.val.val ((ğ”¼.inv.g f).val n) - n)) n hn hnN rfl,
  --     linarith [le_max_right C C1],
  --   specialize H n hnN,
  --   linarith [le_max_left C C1],
  -- end

  -- lemma lemma49 : âˆ€ (a : ğ”¼) (ha : a âˆˆ P), âˆƒ b, a * b = 1 :=
  -- begin
  --   rintro a âŸ¨f, hf, hâŸ©,
  --   have hfP' : f âˆˆ P',  
  --     exact h,
  --   use â†‘(ğ”¼.inv.g âŸ¨f, hfP'âŸ©),
  --   rw â† hf,
  --   simp only [ğ”¼.mul_eq', ğ”¼.one_eq'],
  --   rw [lemma17, quotient_add_group.eq],
  --   apply lemma4,
  --   cases lemma48 âŸ¨f, hfP'âŸ© with C hC,
  --   use C,
  --   intros p hp,
  --   specialize hC p hp,
  --   rw â† abs_neg at hC,
  --   simp at hC,
  --   rw [add_comm],
  --   simp,
  --   exact hC,
  -- end

  -- lemma lemma50 : âˆ€ a b, a âˆˆ P â†’ b âˆˆ P â†’ a * b âˆˆ P :=
  -- begin
  --   intros a b ha hb,
  --   rcases ha with âŸ¨u, hu, haâŸ©,
  --   rcases hb with âŸ¨v, hv, hbâŸ©,
  --   rw [â† hu, â† hv],
  --   simp only [ğ”¼.mul_eq'],
  --   rw lemma17,
  --   use [âŸ¨u.val âˆ˜ v.val, lemma14 u vâŸ©, rfl],
  --   rw lemma8 at *,
  --   intros C hC,
  --   cases ha C hC with M hM,
  --   have : 0 < max M 1,
  --     rw lt_max_iff,
  --     right,
  --     norm_num,
  --   cases hb (max M 1) this with N hN,
  --   use N,
  --   intros p hNp,
  --   specialize hN p hNp,
  --   have hvval : M < v.val p,
  --     rw max_lt_iff at hN,
  --     exact hN.1,
  --   specialize hM (v.val p) hvval,
  --   exact hM,
  -- end

  -- lemma lemma51 : (1 : ğ”¼) âˆˆ P :=
  -- begin
  --   use [(âŸ¨(id : â„¤ â†’ â„¤), lemma16âŸ© : S), rfl],
  --   intros n hn,
  --   use n + 1,
  --   split,
  --     linarith,
  --   norm_num,
  -- end

  -- noncomputable def ğ”¼.inv : ğ”¼ â†’ ğ”¼ := Î» a,
  -- if ha1 : a âˆˆ P then begin
  --   choose b hb using lemma49 a ha1,
  --   exact b,
  -- end 
  -- else if ha2 : a = 0 then (0 : ğ”¼) else begin
  --   choose b hb using lemma49 (-a) (lemma30 ha1 ha2),
  --   exact -b,
  -- end

  -- noncomputable instance field_ğ”¼ : field ğ”¼ :=
  -- { inv := ğ”¼.inv,
  --   exists_pair_ne := begin
  --     use [0, 1],
  --     have h0P := lemma10,
  --     have h1P := lemma51,
  --     intro h01,
  --     rw h01 at h0P,
  --     exact h0P h1P,
  --   end,
  --   mul_inv_cancel := begin
  --     intros a ha,
  --     show a * (ğ”¼.inv a) = 1,
  --     simp only [ğ”¼.inv],
  --     split_ifs,
  --       have := classical.some_spec (lemma49 a h),
  --       exact this,
  --     have := classical.some_spec (ğ”¼.inv._proof_2 a h ha),
  --     have heq : a * -(classical.some (ğ”¼.inv._proof_2 a h ha)) = 
  --       -a * (classical.some (ğ”¼.inv._proof_2 a h ha)),
  --       ring,
  --     rw heq,
  --     exact this,
  --   end,
  --   inv_zero := begin   
  --     show (ğ”¼.inv 0) = 0,
  --     simp only [ğ”¼.inv],
  --     split_ifs,
  --       exfalso,
  --       exact lemma10 h,
  --     refl,
  --   end,
  --   ..comm_ring_ğ”¼ }

  -- lemma ğ”¼.field.zero_eq : field.zero = (0 : ğ”¼) := rfl

  -- lemma ğ”¼.field.one_eq : field.one = (1 : ğ”¼) := rfl

  -- noncomputable instance linear_ordered_field_ğ”¼ : linear_ordered_field ğ”¼ :=
  -- { le := Î» a b, -a + b âˆˆ P âˆª {0},
  --   lt := Î» a b, -a + b âˆˆ P,
  --   le_refl := begin
  --     intro a,
  --     simp,
  --   end,
  --   le_trans := begin
  --     intros a b c hab hbc,
  --     simp at *,
  --     cases hab,
  --     { cases hbc,
  --       { left,
  --         rw [neg_add_eq_zero.mp hab, neg_add_eq_zero.mp hbc],
  --         simp, },
  --       { rw neg_add_eq_zero.mp hab,
  --         cc, }, },
  --     { cases hbc,
  --       { rw â† (neg_add_eq_zero.mp hbc),
  --         cc, },
  --       { right,
  --         have h : (-a + b) + (-b + c) âˆˆ P := lemma9 (-a + b) (-b + c) hab hbc,
  --         have heq : -a + c = (-a + b) + (-b + c),
  --           abel,
  --         rw heq,
  --         exact h, }, },
  --   end,
  --   lt_iff_le_not_le := begin
  --     intros a b,
  --     split,
  --     { intro hab,
  --       simp at hab,
  --       simp,
  --       split,
  --         cc,
  --       intro hfalse,
  --       cases hfalse,
  --       { rw neg_add_eq_zero.mp hfalse at hab,
  --         simp at hab,
  --         exact lemma10 hab, },
  --       { have heq : -b + a = -(-a + b),
  --           abel,
  --         rw heq at hfalse,
  --         exact lemma11 hab hfalse, }, },
  --     { rintro âŸ¨hab, hbaâŸ©,
  --       cases hab,
  --       { exact hab, },
  --       { simp at hab,
  --         simp at hba,
  --         have : Â¬(-b + a = 0),
  --           finish,
  --         exfalso,
  --         apply this,
  --         rw neg_add_eq_zero at *,
  --         exact eq.symm hab, }, },
  --   end,
  --   le_antisymm := begin
  --     intros a b hab hba,
  --     cases hab,
  --     { cases hba,
  --       { exfalso,
  --         have :  -b + a = -(-a + b),
  --           abel,
  --         rw this at hba,
  --         exact lemma11 hab hba, },
  --       { simp at hba,
  --         exact eq.symm (neg_add_eq_zero.mp hba), }, },
  --     { simp at hab,
  --       exact neg_add_eq_zero.mp hab, },
  --   end,
  --   add_le_add_left := begin
  --     intros a b hab c,
  --     show -(c + a) + (c + b) âˆˆ P âˆª {0},
  --     have : -(c + a) + (c + b) = -a + b,
  --       abel,
  --     rw this,
  --     exact hab,
  --   end,
  --   mul_pos := begin
  --     intros a b ha hb,
  --     change -(0 : ğ”¼) + a âˆˆ P at ha,
  --     change -(0 : ğ”¼) + b âˆˆ P at hb,
  --     change -(0 : ğ”¼) + (a * b) âˆˆ P,
  --     simp at *,
  --     exact lemma50 a b ha hb,
  --   end,
  --   le_total := begin
  --     intros a b,
  --     change  -a + b âˆˆ P âˆª {0} âˆ¨ -b + a âˆˆ P âˆª {0},
  --     simp,
  --     cases lemma29 (-a + b),
  --       left,
  --       right,
  --       exact h,
  --     cases h,
  --       left,
  --       left,
  --       exact h,
  --     simp at h,
  --     right,
  --     right,
  --     exact h,
  --   end,
  --   zero_lt_one := begin
  --     simp only [ğ”¼.field.zero_eq, ğ”¼.field.one_eq],
  --     change -(0 : ğ”¼) + 1 âˆˆ P,
  --     ring,
  --     exact lemma51,
  --   end,
  --   ..field_ğ”¼ }

  -- lemma lemma52 : âˆ€ n, (Î» p, n * p) âˆˆ S  := 
  -- begin
  --   intro n,
  --   use 1,
  --   intros p q,
  --   simp,
  --   ring,
  --   norm_num,
  -- end

  -- lemma lemma53 : âˆ€ n : â„•, (n : ğ”¼) = 
  --   @coe â†¥S ğ”¼ eudoxus_reals_group.has_lift_t âŸ¨Î» p, n * p, lemma52 nâŸ© :=
  -- begin
  --   intro n,
  --   induction n,
  --     simp,
  --     refl,
  --   simp,
  --   rw n_ih,
  --   ring,
  --   have : @coe â†¥S ğ”¼ eudoxus_reals_group.has_lift_t âŸ¨has_mul.mul â†‘n_n, lemma52 n_nâŸ© + @coe â†¥S ğ”¼ eudoxus_reals_group.has_lift_t âŸ¨id, lemma16âŸ© = 
  --     @coe â†¥S ğ”¼ eudoxus_reals_group.has_lift_t (âŸ¨has_mul.mul â†‘n_n, lemma52 n_nâŸ© + âŸ¨id, lemma16âŸ©),
  --     refl,
  --   rw this,
  --   simp,
  --   have heq : âˆ€ (z : â„¤), â†‘n_n * z + z = (â†‘n_n + 1) * z,
  --     intro z,
  --     ring,
  --   simp_rw heq,
  -- end

  -- lemma lemma54 (f g : S) (hfg : (â†‘f : ğ”¼) = â†‘g) : (âˆ€ (C : â„¤), 0 < C â†’ (âˆƒ (N : â„¤), âˆ€ (p : â„¤), N < p â†’ C < f.val p))
  --   â†’ (âˆ€ (C : â„¤), 0 < C â†’ (âˆƒ (N : â„¤), âˆ€ (p : â„¤), N < p â†’ C < g.val p)) :=
  -- begin
  --   intro hf,
  --   intros C hC,
  --   have hfg' : (0 : ğ”¼) = -â†‘(f : S) + â†‘(g : S),
  --     rw hfg,
  --     simp,
  --   change â†‘(0 : S) = â†‘(-f + g) at hfg',
  --   rw quotient_add_group.eq at hfg',
  --   simp at hfg',
  --   cases hfg' with B hB,
  --   change âˆ€ (p : â„¤), abs (-f.val p + g.val p) < B at hB,
  --   have h0BC : 0 < B + C,
  --     linarith [hB 0, abs_nonneg (-f.val 0 + g.val 0)],
  --   cases hf (B + C) h0BC with N hN,
  --   use N,
  --   intros p hNp,
  --   specialize hN p hNp,
  --   specialize hB p,
  --   rw abs_lt at hB,
  --   cases hB,
  --   linarith,
  -- end

  -- lemma lemma55 {f g : S} (B : â„¤) : (0 : ğ”¼) < â†‘g â†’ (âˆ€ p, abs (f.1 p) < abs (g.1 p) + B) â†’ (â†‘f : ğ”¼) â‰¤ â†‘g :=
  -- begin
  --   rintro âŸ¨v, hvg, hvâŸ© habs,
  --   simp at hvg,
  --   by_contradiction hfalse,
  --   simp at hfalse,
  --   change â†‘((-g) + f) âˆˆ P at hfalse,
  --   rcases hfalse with âŸ¨gf, hgf, hfalseâŸ©,
  --   rw lemma8 at *,
  --   have h1 := lemma54 gf (-g + f) hgf hfalse,
  --   have h2 := lemma54 v g hvg hv,
  --   have : (0 : â„¤) < max B 1,
  --     rw lt_max_iff,
  --     norm_num,
  --   cases h1 (max B 1) this with N1 h1,
  --   cases h2 (max B 1) this with N2 h2,
  --   have hle1 : N1 < max N1 N2 + 1,
  --     linarith [le_max_left N1 N2],
  --   have hle2 : N2 < max N1 N2 + 1,
  --     linarith [le_max_right N1 N2],
  --   specialize h1 (max N1 N2 + 1) hle1,
  --   specialize h2 (max N1 N2 + 1) hle2,
  --   specialize habs (max N1 N2 + 1),
  --   change max B 1 < -g.val (max N1 N2 + 1) + f.val (max N1 N2 + 1) at h1,
  --   have heq : abs (g.val (max N1 N2 + 1)) = g.val (max N1 N2 + 1),
  --     rw abs_of_pos,
  --     linarith,
  --   rw [heq, abs_lt] at habs,
  --   cases habs,
  --   linarith [le_max_left B 1],
  -- end

  -- instance archimedean_ğ”¼ : archimedean ğ”¼ := 
  -- begin
  --   rw archimedean_iff_nat_le,
  --   intro a,
  --   cases lemma12 a with u hu,
  --   rcases lemma23 u with âŸ¨A, B, hA, hABâŸ©,
  --   have := int.eq_coe_of_zero_le (le_of_lt hA),
  --   cases this with n hAn,
  --   have hn : 0 < n,
  --     rw hAn at hA,
  --     exact int.coe_nat_pos.mp hA,
  --   use n,
  --   rw [â† hu, lemma53],
  --   apply lemma55 B,
  --     rw â† lemma53,
  --     exact nat.cast_pos.mpr hn,
  --   rw â† hAn,
  --   intro p,
  --   specialize hAB p,
  --   have :  A * abs p = abs (A * p),
  --     have heq : abs A * abs p = abs (A * p) := (abs_mul A p).symm,
  --     rw abs_of_pos hA at heq,
  --     exact heq,
  --   rw this at hAB,
  --   exact hAB,
  -- end

  -- noncomputable instance : floor_ring ğ”¼ := archimedean.floor_ring ğ”¼

  -- noncomputable instance decidable_linear_order_ğ”¼ : decidable_linear_order ğ”¼ := classical.DLO ğ”¼

  -- noncomputable instance lattice_ğ”¼ : lattice ğ”¼ := by apply_instance

  -- lemma lemma56 : âˆ€ {x y : ğ”¼} (hxy : x < y), âˆƒ (M N : â„¤) (hN : 0 < N), (N : ğ”¼) * x < (M : ğ”¼) âˆ§ (M : ğ”¼) < (N : ğ”¼) * y :=
  -- begin
  --   intros x y hxy,
  --   rcases exists_rat_btwn hxy with âŸ¨q, hq1, hq2âŸ©,
  --   rcases q with âŸ¨M, N, h1, h2âŸ©,
  --   use [M, N, int.coe_nat_pos.mpr h1],
  --   split,
  --     rw mul_comm,
  --     rw â† lt_div_iff,
  --       exact hq1,
  --       exact int.cast_pos.mpr (int.coe_nat_pos.mpr h1),
  --   rw mul_comm,
  --   rw â† div_lt_iff,
  --     exact hq2,
  --   exact int.cast_pos.mpr (int.coe_nat_pos.mpr h1),
  -- end

  -- lemma lemma57 : âˆƒ C, âˆ€ (a b : ğ”¼), abs (floor (a + b) - floor a - floor b) < C :=
  -- begin
  --   use 2,
  --   intros a b,
  --   have ha1 := floor_le a,
  --   have ha2 := lt_floor_add_one a,
  --   have hb1 := floor_le b,
  --   have hb2 := lt_floor_add_one b,
  --   have : (2 : ğ”¼) = (â†‘2 : ğ”¼),
  --     simp,
  --   have h1 : â†‘âŒŠa + bâŒ‹ - â†‘âŒŠaâŒ‹ - â†‘âŒŠbâŒ‹ < (â†‘2 : ğ”¼),
  --     linarith [floor_le (a + b)],
  --   have h2 : -(â†‘2 : ğ”¼) < â†‘âŒŠa + bâŒ‹ - â†‘âŒŠaâŒ‹ - â†‘âŒŠbâŒ‹,
  --     linarith [lt_floor_add_one (a + b)],
  --   have h3 : â†‘âŒŠa + bâŒ‹ - â†‘âŒŠaâŒ‹ - â†‘âŒŠbâŒ‹ = (â†‘(âŒŠa + bâŒ‹ - âŒŠaâŒ‹ - âŒŠbâŒ‹) : ğ”¼),
  --     simp,
  --   rw h3 at *,
  --   have h1' : âŒŠa + bâŒ‹ - âŒŠaâŒ‹ - âŒŠbâŒ‹ < 2,
  --     rw â† @int.cast_lt ğ”¼,
  --     exact h1,
  --   have h2' : -2 < âŒŠa + bâŒ‹ - âŒŠaâŒ‹ - âŒŠbâŒ‹,
  --     rw â† @int.cast_lt ğ”¼,
  --     exact h2,
  --   rw abs_lt,
  --   split,
  --     linarith,
  --   linarith,
  -- end

  -- @[simp] lemma upper_bounds_eq' {S : set ğ”¼} : upper_bounds S = {x : ğ”¼ | âˆ€ â¦ƒa : ğ”¼â¦„, a âˆˆ S â†’ a â‰¤ x} := rfl

  -- lemma lemma58 (K : set â„¤) (hK1 : set.finite K) (hK2 : K.nonempty) : 
  --   âˆƒ n (hn : n âˆˆ K), âˆ€ t âˆˆ K, t â‰¤ n :=
  -- begin
  --   cases set.finite.exists_finset hK1 with K' hK'K,
  --   have hK' : K'.nonempty,
  --     cases hK2 with x hx,
  --     use x,
  --     rw hK'K,
  --     exact hx,
  --   use finset.max' K' hK',
  --   simp_rw â† hK'K,
  --   use finset.max'_mem K' hK', 
  --   intros t ht,
  --   use finset.le_max' K' t ht,
  -- end

  -- lemma lemma59 (K : set â„¤) (hK1 : K.nonempty) (hK2 : bdd_above K) : 
  --   âˆƒ n (hn : n âˆˆ K), âˆ€ t âˆˆ K, t â‰¤ n :=
  -- begin
  --   cases hK2 with M hM,
  --   simp at hM,
  --   cases hK1 with m hm,
  --   set K' := K âˆ© set.Icc m M with hK'K,
  --   have hK'1 : set.finite K',
  --     have : (set.Icc m M).finite := âŸ¨fintype.of_finset (finset.Ico_â„¤ m (M + 1)) (by {simp [int.lt_add_one_iff]})âŸ©,
  --     rw hK'K,
  --     apply set.finite.subset this,
  --     exact set.inter_subset_right K (set.Icc m M),
  --   have hK'2 : K'.nonempty,
  --     rw hK'K,
  --     use [m, hm],
  --     simp,
  --     apply hM,
  --     exact hm,
  --   rcases lemma58 K' hK'1 hK'2 with âŸ¨n, hn, hâŸ©,
  --   rw hK'K at *,
  --   use [n, hn.1],
  --   intros t htK,
  --   have htm := lt_or_le t m,
  --   cases htm,
  --     have : m â‰¤ n,
  --       rcases hn with âŸ¨hn1, hn2, hn3âŸ©,
  --       exact hn2,
  --     linarith,
  --   apply h,
  --   use [htK, htm, hM htK],
  -- end

  -- lemma lemma60 (p : â„¤) (hp : 0 â‰¤ p) (T : set ğ”¼) (hT1 : T.nonempty) (hT2 : bdd_above T) : 
  --   âˆƒ n (hn : n âˆˆ {m | âˆƒ x âˆˆ T, m = floor ((p : ğ”¼) * x)}), âˆ€ t âˆˆ {m | âˆƒ x âˆˆ T, m = floor ((p : ğ”¼) * x)}, t â‰¤ n :=
  -- begin
  --   have h1 : {m | âˆƒ x âˆˆ T, m = floor ((p : ğ”¼) * x)}.nonempty,
  --     cases hT1 with x hx,
  --     use [âŒŠâ†‘p * xâŒ‹, x, hx],
  --   have h2 : bdd_above {m | âˆƒ x âˆˆ T, m = floor ((p : ğ”¼) * x)},
  --     cases hT2 with M hM,
  --     use âŒŠâ†‘p * MâŒ‹ + 1,
  --     simp only [set.mem_set_of_eq, exists_imp_distrib, upper_bounds_eq],
  --     intros a x hxT hapx,
  --     rw hapx,
  --     have hpxpM : â†‘p * x â‰¤ â†‘p * M,
  --       apply mul_le_mul_of_nonneg_left, 
  --         simp at hM,
  --         exact hM hxT,
  --       exact int.cast_nonneg.mpr hp,
  --     have : â†‘âŒŠâ†‘p * xâŒ‹ â‰¤ â†‘âŒŠâ†‘p * MâŒ‹ + (1 : ğ”¼),
  --       linarith [floor_le (â†‘p * x), lt_floor_add_one (â†‘p * M)],
  --     have heq : â†‘âŒŠâ†‘p * MâŒ‹ + 1 = (â†‘(âŒŠâ†‘p * MâŒ‹ + 1) : ğ”¼),
  --       simp,
  --     rw heq at this,
  --     rw â† @int.cast_le ğ”¼,
  --     exact this,
  --   exact lemma59 {m | âˆƒ x âˆˆ T, m = floor ((p : ğ”¼) * x)} h1 h2,
  -- end

  -- noncomputable def T_sup_f1 (T : set ğ”¼) (hT1 : T.nonempty) (hT2 : bdd_above T) : â„¤ â†’ â„¤ := Î» p, 
  -- if hp : 0 â‰¤ p then begin
  --   choose n hn using lemma60 p hp T hT1 hT2,
  --   exact n,
  -- end
  -- else begin
  --   simp at hp,
  --   have hp' : 0 â‰¤ -p,
  --     linarith,
  --   choose n hn using lemma60 (-p) hp' T hT1 hT2,
  --   exact -n,
  -- end

  -- lemma lemma61 (a p : â„¤) (T : set ğ”¼) (hT1 : T.nonempty) (hT2 : bdd_above T) (hp : 0 â‰¤ p) (m1 m2 : ğ”¼) (hm1 : m1 âˆˆ T) (hm2 : m2 âˆˆ T) :
  --   a = T_sup_f1 T hT1 hT2 p â†’ a = âŒŠâ†‘p * m1âŒ‹ â†’ a = âŒŠâ†‘p * max m1 m2âŒ‹ :=
  -- begin
  --   intros ha1 ha2,
  --   simp only [T_sup_f1] at ha1,
  --   split_ifs at ha1,
  --   rcases classical.some_spec (lemma60 p hp T hT1 hT2) with âŸ¨âŸ¨c, hc, hfc1âŸ©, hfc2âŸ©,
  --   set fp := classical.some (lemma60 p hp T hT1 hT2) with hfpeq,
  --   rw â† hfpeq at *,
  --   have h1 : âŒŠâ†‘p * m1âŒ‹ â‰¤ âŒŠâ†‘p * max m1 m2âŒ‹,
  --     have : (â†‘p * m1 : ğ”¼) â‰¤ â†‘p * max m1 m2,
  --       apply mul_le_mul_of_nonneg_left (le_max_left m1 m2),
  --       exact int.cast_nonneg.mpr hp,
  --     exact floor_mono this,
  --   have h2 : âŒŠâ†‘p * max m1 m2âŒ‹ â‰¤ âŒŠâ†‘p * m1âŒ‹,
  --     specialize hfc2 âŒŠâ†‘p * max m1 m2âŒ‹,
  --     rw ha2 at ha1,
  --     rw â† ha1 at hfc2,
  --     apply hfc2,
  --     use max m1 m2,
  --     split,
  --       cases max_choice m1 m2,
  --         rw h,
  --         exact hm1,
  --       rw h,
  --       exact hm2,
  --     refl,
  --   linarith,
  -- end

  -- noncomputable def T_sup_f (T : set ğ”¼) (hT1 : T.nonempty) (hT2 : bdd_above T) : S := âŸ¨Î» p, T_sup_f1 T hT1 hT2 p, 
  -- begin
  --   apply lemma26,
  --   { intros p hp,
  --     simp only [T_sup_f1],
  --     split_ifs with hp1 hp2,
  --           exfalso,
  --           linarith,
  --         exfalso,
  --         linarith,
  --       refl,
  --     exfalso,
  --     linarith, },
  --   cases lemma57 with C hC,
  --   use C,
  --   intros m n hm hn,
  --   have hmn : 0 â‰¤ m + n,
  --     linarith,
  --   rw abs_lt,
  --   simp,
  --   simp only [T_sup_f1],
  --   split_ifs,
  --   set fm := classical.some (lemma60 m hm T hT1 hT2) with hfmeq,
  --   set fn := classical.some (lemma60 n hn T hT1 hT2) with hfneq,
  --   set fmn := classical.some (lemma60 (m + n) hmn T hT1 hT2) with hfmneq,
  --   rcases classical.some_spec (lemma60 m hm T hT1 hT2) with âŸ¨âŸ¨xm, hxm, hfm1âŸ©, hfm2âŸ©,
  --   rcases classical.some_spec (lemma60 n hn T hT1 hT2) with âŸ¨âŸ¨xn, hxn, hfn1âŸ©, hfn2âŸ©,
  --   rcases classical.some_spec (lemma60 (m + n) hmn T hT1 hT2) with âŸ¨âŸ¨xmn, hxmn, hfmn1âŸ©, hfmn2âŸ©,
  --   rw â† hfmeq at *,
  --   rw â† hfneq at *,
  --   rw â† hfmneq at *,
  --   set x1 := max xm xn with hx1,
  --   have hx1' : x1 = max xn xm,
  --     rw hx1,
  --     exact max_comm xm xn,
  --   have hx1'' : x1 âˆˆ T,
  --     rw hx1,
  --     cases max_choice xm xn,
  --       rw h,
  --       exact hxm,
  --     rw h,
  --     exact hxn,
  --   have hx11 := lemma61 fm m T hT1 hT2 hm xm xn hxm hxn,
  --   have : fm = T_sup_f1 T hT1 hT2 m,
  --     simp only [T_sup_f1],
  --     split_ifs,
  --     exact hfmeq,
  --   specialize hx11 this hfm1,
  --   have hx12 := lemma61 fn n T hT1 hT2 hn xn xm hxn hxm,
  --   have : fn = T_sup_f1 T hT1 hT2 n,
  --     simp only [T_sup_f1],
  --     split_ifs,
  --     exact hfneq,
  --   specialize hx12 this hfn1,
  --   rw â† hx1 at hx11,
  --   rw â† hx1' at hx12,
  --   set x := max x1 xmn with hx,
  --   have hx' : x = max xmn x1,
  --     rw hx,
  --     exact max_comm x1 xmn,
  --   have hx01 := lemma61 fm m T hT1 hT2 hm x1 xmn hx1'' hxmn,
  --   have : fm = T_sup_f1 T hT1 hT2 m,
  --     simp only [T_sup_f1],
  --     split_ifs,
  --     exact hfmeq,
  --   specialize hx01 this hx11,
  --   have hx02 := lemma61 fn n T hT1 hT2 hn x1 xmn hx1'' hxmn,
  --   have : fn = T_sup_f1 T hT1 hT2 n,
  --     simp only [T_sup_f1],
  --     split_ifs,
  --     exact hfneq,
  --   specialize hx02 this hx12,
  --   have hx03 := lemma61 fmn (m + n) T hT1 hT2 hmn xmn x1 hxmn hx1'',
  --   have : fmn = T_sup_f1 T hT1 hT2 (m + n),
  --     simp only [T_sup_f1],
  --     split_ifs,
  --     exact hfmneq,
  --   specialize hx03 this hfmn1,
  --   rw â† hx at hx01,
  --   rw â† hx at hx02,
  --   rw â† hx' at hx03,
  --   have hmxnx : â†‘(m + n) * x = â†‘m * x + â†‘n * x,
  --     have heq : (â†‘(m + n) : ğ”¼) = â†‘m + â†‘n,
  --       simp,
  --     rw heq,
  --     ring,
  --   rw hmxnx at hx03,
  --   specialize hC (â†‘m * x) (â†‘n * x),
  --   rw abs_lt at hC,
  --   split,
  --     linarith,
  --   linarith,
  -- endâŸ©

  -- lemma lemma62 : âˆ€ (x y : ğ”¼) (hxy : x < y), âˆƒ (M N : â„¤) (hN : 0 < N), x < (M : ğ”¼) / (N : ğ”¼) âˆ§ (M : ğ”¼) / (N : ğ”¼) < y :=
  -- begin
  --   intros x y hxy,
  --   rcases exists_rat_btwn hxy with âŸ¨q, hq1, hq2âŸ©,
  --   rcases q with âŸ¨M, N, h1, h2âŸ©,
  --   use [M, N, int.coe_nat_pos.mpr h1, hq1, hq2],
  -- end

  -- noncomputable def T_sup (T : set ğ”¼) : ğ”¼ := 
  -- if hT1 : T.nonempty âˆ§ bdd_above T then
  --   if hT2 : âˆƒ x âˆˆ T, âˆ€ y âˆˆ T, y â‰¤ x then begin
  --     choose x hx using hT2,
  --     exact x,
  --   end 
  --   else (â†‘(T_sup_f T hT1.1 hT1.2) : ğ”¼)
  -- else 0

  -- lemma lemma63 (f g : S) : (âˆ€ p (hp : 0 â‰¤ p), f.1 p â‰¤ g.1 p) â†’ (â†‘f : ğ”¼) â‰¤ (â†‘g : ğ”¼) :=
  -- begin
  --   intro h,
  --   by_contradiction hfalse,
  --   simp at hfalse,
  --   change â†‘(-g + f) âˆˆ P at hfalse,
  --   rcases hfalse with âŸ¨gf, hgf, hfalseâŸ©,
  --   have := lemma54 gf (-g + f) hgf,
  --   rw lemma8 at hfalse,
  --   specialize this hfalse,
  --   have h01 : (0 : â„¤) < 1,
  --     norm_num,
  --   cases this 1 h01 with N hN,
  --   have hN01 : N < max (N + 1) 0,
  --     linarith [le_max_left (N + 1) 0],
  --   have hN02 : 0 â‰¤ max (N + 1) 0,
  --     exact le_max_right (N + 1) 0,
  --   specialize hN (max (N + 1) 0) hN01,
  --   specialize h (max (N + 1) 0) hN02,
  --   simp only [S.add_eq', S.add_eq, S.neg_eq', lt_neg_add_iff_add_lt, S.neg_eq] at hN,
  --   linarith,
  -- end

  -- lemma lemma64 : âˆ€ n : â„¤, (n : ğ”¼) = 
  --   @coe â†¥S ğ”¼ eudoxus_reals_group.has_lift_t âŸ¨Î» p, n * p, lemma52 nâŸ© :=
  -- begin
  --   intro n,
  --   cases le_or_lt n 0,
  --     have hn : 0 â‰¤ -n,
  --       linarith,
  --     cases int.eq_coe_of_zero_le hn with n' hn',
  --     have := lemma53 n',
  --     have heq1 : (â†‘n : ğ”¼) = -â†‘(â†‘n' : â„¤),
  --       rw â† hn',
  --       simp,
  --     have heq2 : (â†‘n : ğ”¼) = -â†‘(n' : â„•),
  --       rw heq1,
  --       simp,
  --     have heq3 : (â†‘(âŸ¨Î» (p : â„¤), n * p, lemma52 nâŸ© : S) : ğ”¼) = -â†‘(âŸ¨Î» (p : â„¤), â†‘n' * p, lemma52 â†‘n'âŸ© : S),
  --       rw â† hn',
  --       show â†‘(âŸ¨Î» (p : â„¤), n * p, lemma52 nâŸ© : S) = â†‘(-âŸ¨Î» (p : â„¤), -n * p, lemma52 (-n)âŸ© : S),
  --       rw quotient_add_group.eq,
  --       use 1,
  --       intro p,
  --       norm_num,
  --     linarith,
  --   have hn : 0 â‰¤ n,
  --     linarith,
  --   cases int.eq_coe_of_zero_le hn with n' hn',
  --   rw hn',
  --   exact lemma53 n',
  -- end

  -- lemma T_le_cSup : âˆ€ (s : set ğ”¼) (a : ğ”¼), bdd_above s â†’ a âˆˆ s â†’ a â‰¤ T_sup s :=
  -- begin
  --   intros T x hT hxT,
  --   simp only [T_sup],
  --   split_ifs with hT1 hT3,
  --   { cases classical.some_spec hT3,
  --     exact h x hxT, },
  --   { have hT3' : âˆ€ (x : ğ”¼) (H : x âˆˆ T), âˆƒ (y : ğ”¼), y âˆˆ T âˆ§ x < y,
  --       rw not_exists at hT3,
  --       intros x hx,
  --       specialize hT3 x,
  --       rw not_exists at hT3,
  --       specialize hT3 hx,
  --       rw not_forall at hT3,
  --       cases hT3 with y hy,
  --       use y,
  --       rw not_imp at hy,
  --       cases hy with hy1 hy2,
  --       simp at hy2,
  --       use [hy1, hy2],
  --     rcases hT3' x hxT with âŸ¨y, hy, hxyâŸ©,
  --     rcases lemma62 x y hxy with âŸ¨M, N, hN, hMN1, hMN2âŸ©,
  --     have : âˆ€ p (h0p : 0 â‰¤ p), p * M â‰¤ T_sup_f1 T hT1.1 hT1.2 (p * N),
  --       intros p hp,
  --       have hpN0 : 0 â‰¤ p * N,
  --         apply mul_nonneg hp,
  --         linarith,
  --       simp only [T_sup_f1],
  --       split_ifs,
  --       rcases classical.some_spec (lemma60 (p * N) hpN0 T hT1.1 hT1.2) with âŸ¨âŸ¨xm, hxmT, hsome1âŸ©, hsome2âŸ©,
  --       rw hsome1 at *,
  --       specialize hsome2 âŒŠâ†‘(p * N) * yâŒ‹,
  --       rw set.mem_set_of_eq at hsome2,
  --       have : âˆƒ (x : ğ”¼) (H : x âˆˆ T), âŒŠâ†‘(p * N) * yâŒ‹ = âŒŠâ†‘(p * N) * xâŒ‹,
  --         use [y, hy, rfl],
  --       specialize hsome2 this,
  --       have :  âŒŠ(â†‘(p * N) : ğ”¼) * (â†‘M : ğ”¼) / (â†‘N : ğ”¼)âŒ‹ â‰¤ âŒŠ(â†‘(p * N) : ğ”¼) * (y : ğ”¼)âŒ‹,
  --         apply floor_mono,
  --         rw [div_eq_mul_inv, mul_assoc],
  --         apply mul_le_mul_of_nonneg_left,
  --           rw [â† div_eq_mul_inv],
  --           linarith,
  --         exact int.cast_nonneg.mpr hpN0,
  --       have heq : (â†‘(p * N) : ğ”¼) * (â†‘M : ğ”¼) / (â†‘N : ğ”¼) = (â†‘(p * M) : ğ”¼),
  --         have heq1 : âˆ€ N : â„¤, (â†‘(p * N) : ğ”¼) = â†‘p * â†‘N, 
  --           intro N,
  --           simp,
  --         rw [heq1 N, heq1 M, mul_comm, div_eq_mul_inv, mul_assoc, mul_assoc, mul_inv_cancel],
  --           ring,
  --         simp,
  --         linarith,
  --         rw heq at this,
  --       have heq' : âŒŠ(â†‘(p * M) : ğ”¼)âŒ‹ = p * (M : â„¤),
  --         rw floor_eq_iff,
  --         split,
  --           linarith,
  --         linarith,
  --       linarith,
  --     have H := lemma63 (âŸ¨(Î» p, M * p), lemma52 MâŸ©),
  --     set fN := (T_sup_f T hT1.1 hT1.2).1 âˆ˜ (âŸ¨(Î» p, N * p), lemma52 NâŸ© : S).1 with hfN1,
  --     have hfN2 : fN âˆˆ S,
  --       rw hfN1,
  --       apply lemma14 (T_sup_f T hT1.1 hT1.2) âŸ¨(Î» p, N * p), lemma52 NâŸ©,
  --     specialize H (âŸ¨fN, hfN2âŸ© : S),  
  --     dsimp at H,
  --     dsimp at hfN1,
  --     have : (âˆ€ (p : â„¤), 0 â‰¤ p â†’ M * p â‰¤ fN p),
  --       rw hfN1,
  --       intros p h0p,
  --       specialize this p h0p,
  --       have heq : T_sup_f1 T hT1.1 hT1.2 (p * N) = (â†‘(T_sup_f T hT1.1 hT1.2) âˆ˜ has_mul.mul N) p,
  --         simp,
  --         rw mul_comm,
  --         simp only [T_sup_f],
  --         simp,
  --       rw [â† heq, mul_comm],
  --       exact this,
  --       specialize H this,
  --     have heq1 : (M : ğ”¼) = (âŸ¨has_mul.mul M, lemma52 MâŸ© : S) := lemma64 M,
  --     have heq2 : â†‘(âŸ¨fN, hfN2âŸ© : S) = â†‘(T_sup_f T hT1.1 hT1.2) * (â†‘N : ğ”¼),
  --       simp_rw hfN1,
  --       rw [lemma64 N, ğ”¼.mul_eq', lemma17],
  --       simp,
  --     rw [â† heq1, heq2, mul_comm] at H,
  --     have := (@div_le_iff' ğ”¼ (linear_ordered_field_ğ”¼) (â†‘M) (â†‘N) (â†‘(T_sup_f T hT1.1 hT1.2)) (int.cast_pos.mpr hN)).mpr H,
  --     linarith, },
  --   { exfalso,
  --     simp at hT1,
  --     cases set.eq_empty_or_nonempty T,
  --       rw h at hxT,
  --       exact hxT,
  --     exact hT1 h hT, },
  -- end

  -- lemma T_cSup_le : âˆ€ (s : set ğ”¼) (a : ğ”¼), s.nonempty â†’ a âˆˆ upper_bounds s â†’ T_sup s â‰¤ a :=
  -- begin
  --   intros T y hT1 hyT,
  --   have hT2 : bdd_above T,
  --     use [y, hyT],
  --   have hT : T.nonempty âˆ§ bdd_above T := âŸ¨hT1, hT2âŸ©,
  --   simp only [T_sup],
  --   split_ifs,
  --   { simp at hyT, 
  --     cases classical.some_spec h with hs1 hs2,
  --     exact hyT hs1, },
  --   { by_contradiction hfalse,
  --     rw not_le at hfalse,
  --     rcases lemma56 hfalse with âŸ¨M, N, hN, hMN1, hMN2âŸ©,
  --     have heq1 := lemma64 M,
  --     have hin := lemma14 (T_sup_f T hT1 hT2) âŸ¨has_mul.mul N, lemma52 NâŸ©,
  --     have heq2 : (â†‘N : ğ”¼) * â†‘(T_sup_f T hT1 hT2) = â†‘(âŸ¨(â†‘(T_sup_f T hT1 hT2) âˆ˜ has_mul.mul N), hinâŸ© : S),
  --       rw [mul_comm, ğ”¼.mul_eq', lemma64 N, lemma17],
  --       refl,
  --     rw [heq1, heq2] at hMN2,
  --     simp only [T_sup_f, subtype.coe_mk, subtype.val_eq_coe] at hMN2,
  --     rcases hMN2 with âŸ¨sum, hsumeq, HâŸ©,
  --     rw lemma8 at H,
  --     change â†‘sum = â†‘(-(âŸ¨has_mul.mul M, lemma52 MâŸ© : S) + âŸ¨T_sup_f1 T hT1 hT2 âˆ˜ has_mul.mul N, hinâŸ©) at hsumeq,
  --     have := lemma54 sum (-(âŸ¨has_mul.mul M, lemma52 MâŸ© : S) + âŸ¨T_sup_f1 T hT1 hT2 âˆ˜ has_mul.mul N, hinâŸ©) hsumeq H,
  --     rw â† lemma8 at this,
  --     have h01 : (0 : â„¤) < 1,
  --       norm_num,
  --     rcases this 1 h01 with âŸ¨p, h0p, hfpâŸ©,
  --     simp at hfp,
  --     have hcomm : N * p = p * N := mul_comm N p,
  --     rw [mul_comm, hcomm] at hfp,
  --     have hpN : 0 â‰¤ p * N := le_of_lt (mul_pos h0p hN),
  --     have hx : âˆƒ x âˆˆ T, T_sup_f1 T hT1 hT2 (p * N) = âŒŠâ†‘(p * N) * xâŒ‹,
  --       simp only [T_sup_f1],
  --       split_ifs,
  --       cases classical.some_spec (lemma60 (p * N) hpN T hT1 hT2) with hsome1 hsome2,
  --       exact hsome1,
  --     rcases hx with âŸ¨x, hxT, hxâŸ©,
  --     specialize hyT hxT,
  --     have hle1 : â†‘(p * N) * x â‰¤ â†‘(p * N) * y := mul_le_mul_of_nonneg_left hyT (int.cast_nonneg.mpr hpN),
  --     have heq3 : â†‘(p * N) * y = â†‘p * (â†‘N * y),
  --       rw â† mul_assoc,
  --       simp,
  --     have hle2 : â†‘p * (â†‘N * y) < â†‘p * â†‘M,
  --       rw mul_lt_mul_left,
  --         exact hMN1,
  --       exact int.cast_pos.mpr h0p,
  --     have hle3 : â†‘(p * N) * x < â†‘p * â†‘M,
  --       linarith,
  --     rw hx at hfp,
  --     have hle4 : âŒŠ(â†‘(p * N) : ğ”¼) * xâŒ‹ â‰¤ âŒŠ(â†‘p : ğ”¼) * (â†‘M : ğ”¼)âŒ‹ := floor_mono (le_of_lt hle3),
  --     have heq4 : âŒŠ(â†‘p : ğ”¼) * (â†‘M : ğ”¼)âŒ‹ = p * M,
  --       rw floor_eq_iff,
  --       split,
  --         simp,
  --       have : (â†‘(p * M) : ğ”¼) = â†‘p * â†‘M,
  --         simp,
  --       linarith,
  --     linarith, },
  -- end

  -- @[simp] lemma lower_bounds_eq' {S : set ğ”¼} : lower_bounds S = {x : ğ”¼ | âˆ€ â¦ƒa : ğ”¼â¦„, a âˆˆ S â†’ x â‰¤ a} := rfl

  -- lemma T_cInf_le : âˆ€ (s : set ğ”¼) (a : ğ”¼), bdd_below s â†’ a âˆˆ s â†’ -T_sup {x : ğ”¼ | -x âˆˆ s} â‰¤ a :=
  -- begin
  --   intros T x hT hxT,
  --   cases hT with y hy,
  --   simp at hy,
  --   have h1 : bdd_above {x : ğ”¼ | -x âˆˆ T},
  --     use -y,
  --     intros a ha,
  --     simp at ha,
  --     specialize hy ha,
  --     linarith,
  --   have := T_le_cSup {x : ğ”¼ | -x âˆˆ T} (-x) h1,
  --   have h2 : -x âˆˆ {x : ğ”¼ | -x âˆˆ T},
  --     simp,
  --     exact hxT,
  --   specialize this h2,
  --   linarith,
  -- end

  -- lemma T_le_cInf : âˆ€ (s : set ğ”¼) (a : ğ”¼), s.nonempty â†’ a âˆˆ lower_bounds s â†’ a â‰¤ -T_sup {x : ğ”¼ | -x âˆˆ s} :=
  -- begin
  --   intros T x hT hxT,
  --   cases hT with y hy,
  --   simp at hxT,
  --   have h1 : (-x) âˆˆ upper_bounds {x : ğ”¼ | -x âˆˆ T},
  --     intros a ha,
  --     specialize hxT ha,
  --     linarith,
  --   have h2 : {x : ğ”¼ | -x âˆˆ T}.nonempty,
  --     use -y,
  --     simp,
  --     exact hy,
  --   have := T_cSup_le {x : ğ”¼ | -x âˆˆ T} (-x) h2 h1,
  --   linarith,
  -- end

  -- noncomputable instance : conditionally_complete_linear_order ğ”¼ :=
  -- { Sup := Î» T, T_sup T,
  --   Inf := Î» T, -T_sup {x | -x âˆˆ T},
  --   le_cSup := T_le_cSup,
  --   cSup_le := T_cSup_le,
  --   cInf_le := T_cInf_le,
  --   le_cInf := T_le_cInf,
  --   ..decidable_linear_order_ğ”¼,
  --   ..lattice_ğ”¼ }
  
-- end quotient
